# 4. Hash(해시)

* 효율적인 데이터 관리를 위해 임의의 길이 데이터를 고정 길이 데이터로 매핑
* 데이터가 많아지면, 다른 데이터 해시값과 같아지는 충돌현상(collision) 발생



### 1. Hash Table(해시 테이블)

* 해시는 내부적으로 배열 사용하여 데이터 저장
  * 인덱스로 접근해서 검색이 빠르지만
  * 충돌(collision)이 있기 때문에, 항상 O(1)은 아님
* 인덱스로 저장되는 Key = 해시값
* 충돌에도 불구하고 사용 이유
  * 겁색이 빠르고
  * 하드디스크나 클라우드의 무한한 데이터를, 유한한 갯수의 해시값으로 매핑하기 때문에  => 적은 자원으로 많은 데이터를 관리 가능



### 2. 해시 함수 (Hash Function / Hash method)

* 데이터를 작은 범위의 값인 해시 코드로 리턴
* 무조건 일대일 대응으로 하기보단, 충돌을 최소화하고, 이를 대비하는게 중요
  * 일대일 대응이 되게 하는 것이 불가능
  * 그렇게 만들어봤자 array와 다를바없어서 메모리 효율이 낮음
* 너무 많은 충돌이 있으면 검색 시, 시간복잡도가 O(n)에 가까워짐



### 3. 해시 충돌 해결 / 대응

* 분리 연결법 / 체이닝

  * 충돌이 났을 때, 해당 키에, 대응되는 데이터들을 연결리스트로 연결

  * 장단점

    * 장점

      →   삽입/삭제가 연결리스트라서 간단

    * 단점 

      →   연결리스트 자체가 삽입/삭제 시 오버헤드가 발생

  * 연결리스트 대신 트리로 구성 가능

    * key-value 쌍의 갯수가 많은 경우 사용
    
      > 트리 내부에서 값을 log(n)에 찾을 수 있어서
      >
      > But, 데이터가 적으면, 트리 내부 검색 연산을 하는 것보다 그냥 선형 탐색하는 게 더 빠를 수 있음

* 개방 주소법 (Open Addressing)

  * 충돌 발생 시, 해시함수로 얻은 주소 아닌, 다른 주소(버킷)에 데이터 저장

  * 방식

    * 선형 탐사
      
      →   충돌 시, 정해진 고정 폭으로 옮겨, 다음 버킷에 저장
    * 제곱 탐사
      
      →   제곱만큼 건너뛴 버킷에 저장
      
    * 데이터가 많아질 수록 제곱탐사가 선형탐사보다 효율적

    * 근데 애초에 얘는 데이터 적을 때 사용하는 게 좋음

  * 장단점

    * 장점 

      →   체이닝 처럼 포인터 필요 X => 메모리 효율 더 좋음

      →   연결리스트를 사용하지 않기 때문에 삽입/삭제 시 오버헤드 적다

    * 단점

      →   최악의 경우, 빈 버킷 찾지 못하고, 탐색 시작위치로 돌아옴

      →   해시값에 따라 특정 위치에만 데이터 몰릴 수 있음
      
      →   그래서 데이터 많을 때는 사용하지 않는 게 좋음

* 두 방식 비교

  * 공통점

    * 최악의 경우 복잡도 O(n)

  * 차이점

    * Open Address는 연속된 공간에 데이터 저장 (충돌 나면 바로 그 다음 그 다음에 저장하니까)

      →   따라서 Separate Chaining보다 캐시 효율 좋다

      →   따라서 데이터 갯수 적다면 Open address가 더 성능 좋음

    * Open Address는 Separate Chaining보다 버킷을 계속 사용

      →   따라서 Separate Chaining이 개방주소법보다 테이블 확장을 늦출 수 있음