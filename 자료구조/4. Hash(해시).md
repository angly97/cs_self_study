# 4. Hash(해시)

* 효율적인 데이터 관리를 위해 임의의 길이 데이터를 고정 길이 데이터로 매핑
* 해시함수로 데이터를 해시값으로 매핑
* 데이터가 많아지면, 다른 데이터 해시값과 같아지는 충돌현상(collision) 발생



### 1. Hash Table(해시 테이블)

* 해시는 내부적으로 배열 사용하여 데이터 저장
  * 빠른 검색 속도 (인덱스로 접근해서)
  * 그러나 항상 O(1)은 아님
    * collision 때문에
* 인덱스로 저장되는 Key = 해시값
* 충돌에도 불구하고 사용 이유
  * 적은 자원으로 많은 데이터 효율적 관리
    * 하드디스크나 클라우드의 무한한 데이터를 유한한 갯수 해시값으로 매핑하기에
  * 검색이 빠름 O(1)



### 2. Hash Function(Hash method; 해시 함수)

* 저장될 값을 작은 범위의 값인 해시 코드로 리턴
* 무조건 일대일 대응으로 하기보단, collision을 최소화하고, 이에 대비해 어떤 대응할지가 중요
  * 일대일 대응이 되게 하는 것이 불가능
  * 그렇게 만들어봤자 array와 다를바없어서 메모리 차지 커짐
* 너무 많은 collision이 있으면 검색 시, 시간복잡도가 O(n)에 가까워짐



### 3. 해시 충돌 해결

* 체이닝 (분리 연결법)

  * 충돌 발생 시, 해당 키에, 대응되는 데이터들을 연결리스트로 연결

  * 각 버킷들을 연결리스트로 만들어 collision 발생 시, 버킷읠 리스트에 추가

  * 장단점

    * 장점

      →   삭제/삽입 간단

    * 단점 

      →   메모리 문제

      →   연결리스트 자체가 삽입/삭제 시 오버헤드

  * 연결리스트 대신 트리로 구성 가능

    * key-value 쌍의 갯수가 많은 경우 사용
    * 트리는 메모리 사용량이 많기 때문에
    * 최악의 상황에서 연결리스트와 성능차이 없지만, 메모리 측면에선 데이터 수 적을 땐 연결리스트 사용

* Open Addressing (개방 주소법)

  * 충돌 발생 시, 해시함수로 얻은 주소 아닌, 다른 주소(버킷)에 데이터 저장

  * if 해당 키 값에 저장되어있으면 다음 주소에 저장

    * 선형 탐사
      * 충돌 시, 정해진 고정 폭으로 옮겨(다음 버킷) 저장
    * 제곱 탐사
      * 제곱만큼 건너뛴 버켓에 저장

  * 장단점

    * 장점 

      →   체이닝 처럼 포인터 필요 X

      →   지정 메모리 외에 추가 공간 필요 X

      →   삽입/삭제 시 오버헤드 적다

    * 단점

      →   최악의 경우, 빈 버킷 찾지 못하고, 탐색 시작위치로 돌아옴

      →   특정 위치에만 데이터 몰릴 수 있음

* 두 방식 비교

  * 공통점

    * 최악의 경우 복잡도 O(n)

  * 차이점

    * Open Address는 연속된 공간에 데이터 저장 (충돌 나면 바로 그 다음 그 다음에 저장하니까)

      →   따라서 Separate Chaining보다 캐시 효율 좋다

      →   따라서 데이터 갯수 적다면 Open address가 더 성능 좋음

    * Open Address는 Separate Chaining보다 버킷을 계속 사용

      →   따라서 Separate Chaining이 버킷 확장을 늦출 수 있음