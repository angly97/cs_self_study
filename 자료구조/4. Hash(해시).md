# 4. Hash(해시)



### 1. 해시

* 효율적인 데이터 관리를 위해 임의의 길이 데이터를 고정 길이 데이터로 매핑
* 해시는 **내부적으로 배열 사용하여 데이터 저장. 즉 해시테이블** 이용
  * 해시 테이블
    * 키값 구조로 데이터를 관리하는 테이블
    * 인덱스 값은 = 해시값
    * 인덱스로 접근해서 검색이 빠르지만
    * 충돌(collision)이 있기 때문에, 항상 O(1)은 아님

* 데이터가 많아지면, 다른 데이터 해시값과 같아지는 충돌현상(collision) 발생
* 충돌에도 불구하고 사용 이유
  * **검색이 빠르고**
  * **방대하고 무한한 데이터를, 유한한 갯수의 해시값으로 매핑하기 때문에  => 적은 자원으로 많은 데이터를 관리 가능**



### 2. 해시 함수 (Hash Function / Hash method)

* 데이터를, 더 작은 범위의 해시값으로 리턴하는 함수
* 무조건 일대일 대응으로 하기보단, 충돌을 최소화하고, 이를 대비하는게 중요
  * 일대일 대응이 되게 하는 것이 불가능
  * 그렇게 만들어봤자 array와 다를바없어서 메모리 효율이 낮음
* 너무 많은 충돌이 있으면 검색 시, 시간복잡도가 O(n)에 가까워짐



### 3. 해시 충돌 해결 / 대응

* 분리 연결법 / 체이닝

  * 충돌이 났을 때, 해당 키에, 대응되는 데이터들을 연결리스트로 연결

  * 장단점

    * 장점

      →   삽입/삭제가 연결리스트라서 간단

    * 단점 

      →   연결리스트 자체가 삽입/삭제 시 오버헤드가 발생

  * 연결리스트 대신 **트리로 구성 가능**

    * key-value 쌍의 갯수가 많은 경우 사용
    
      > 트리 내부에서 값을 log(n)에 찾을 수 있어서
      >
      > But, 데이터가 적으면, 트리 내부에서 log(n)으로 검색 연산을 하는 것보다 그냥 선형 탐색하는 게 더 빠를 수 있음

* 개방 주소법 (Open Addressing)

  * 충돌 발생 시, 해시값이 아니라, 다른 주소(버킷)에 저장

  * 방식

    * 선형 탐사

      →   충돌 시, 정해진 고정 폭으로 옮겨, 다음 버킷에 저장

      →   특정 영역에 데이터 몰릴 수 있고, 이때 성능이 떨어진다

      →   왜냐면, 몰린 부분에서 선형적으로 탐색을 하기 때문에 몰린 데이터 수만큼시간이 걸림

    * 제곱 탐사

      →   보폭을 제곱하여 늘려가면서, 건너뛴 버킷에 저장

      ```
       h(x), h(x)+1, h(x)+4, h(x)+9, h(x)+16...
      ```

      →   특정 영역에 데이터 몰려도, 그 영역을 빨리 벗어날 수 있음 => 그래서 데이터가 많을 땐, 선형 탐사보다는 좀 더 효율적

      →   그러나, **여러개 원소가 초기 해쉬값이 같은** 경우, 모두 같은 순서로 조사를 하기 때문에 비효율적

    * 더블 해싱 (Double Hashing)

      →   서로 다른 해시함수 2개를 사용하여, 이 두개의 해시값을 더한 결과를 보폭으로 옮김

      →   이전 방식보다 더 분산되게 저장 가능
      
      ```
      hi(x) = (h(x)+i*f(x)) mod m (m : 해시테이블 크기)
      ```

  * 주의점

    * **원소 삭제** 시에, 해당 버킷을 **비우지 말고 DELETED라는 표시**를 하는 게 좋음

      > 왜냐면, 이전에 삽입되었던 부분이 삭제되어 빈 후에, 새로운 원소가 그곳에 삽입됨으로써 삽입 순서가 뒤틀리게 되기 때문 
      >
      > (데이터 추가한 순서대로 출력하는 경우가 필요할 때 문제 발생)

  * 장단점

    * 장점 

      →   체이닝 처럼 포인터 필요없고, **테이블 크기만큼만 이용 => 메모리 효율** 더 좋음

      →   연결리스트를 사용하지 않기 때문에 삽입/삭제 시 오버헤드 적다

    * 단점

      →   최악의 경우, **빈 버킷 찾지 못하고, 탐색 시작위치**로 돌아옴

      →   테이블의 크기 이상을 적재할 수 없기 때문에, 그 이상이 되면, 테이블을 2배로 키우고 모든 원소를 다시 해시해야 함
      
      →   **특정 위치에만 데이터 몰릴 수 있음**
      
      >  데이터가 몰리면, => 데이터 많을 때, 버킷을 순차적으로 추가적인 탐사를 하기 때문에, 사용하지 않는 게 좋음

* 체이닝 VS 개방 주소법 비교

  * 공통점

    * **최악의 경우 복잡도 O(n)**

  * 차이점

    * Open Address는 **연속된 공간에 데이터 저장** (충돌 나면 바로 그 다음 그 다음에 저장하니까)

      →   따라서 Separate Chaining보다 캐시 효율 좋다

      →   따라서 데이터 갯수 적다면 Open address가 더 성능 좋음

    * Open Address는 Separate Chaining보다 버킷을 계속 사용

      →   따라서 Separate Chaining이 개방주소법보다 테이블 확장을 늦출 수 있음