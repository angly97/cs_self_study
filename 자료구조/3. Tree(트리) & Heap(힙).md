# 3. Tree(트리) & Heap(힙)

> 알아야 할 것 = 트리 특성 / 힙의 개념 / 힙의 삽입&삭제

### 1. Tree(트리)

* Node와 Edge로 이루어진 자료구조

* 특징

  * 사이클 존재 X (사이클이 있다면 그건 그래프)

  * 노드는 자료형이 될 수 있음

    ```java
    class Node {
        public String name;
        public Node[] children;
    }
    ```

  * 루트에서 한 노드로 가는 경로는 하나뿐

  * 노드가 N개, 간선 N-1개

* cf. 터미널 노드 == 리프노드 == 단말 노드 / 인터널 노드 == 내부 노드 == 비단말 노드

* 사용 이유

  * 정렬된 트리일 때, 값을 빨리 찾을 수 있음
    * 각 루트와 값을 비교하면서

* 순회 방식
  <img src="https://user-images.githubusercontent.com/70613905/163101845-9d10a191-33dd-4d2c-b800-996fe6c8d07b.JPG" alt="image-20220413101543217" style="zoom:67%;" />

  * 전위 순회(pre-order)

    * 각 루트를 순차적으로 먼저 방문
    * 루트 => 왼쪽 자식 => 오른쪽 자식
    * DFS

    * 1, 2, 4, 8, 9, 5, 10, 11, 3, 6, 13, 7, 14

  * 중위 순회(in-order)

    * 왼쪽 하위 트리 방문 후, 루트 방문
    * 왼쪽 자식 => 루트 => 오른쪽 자식
    * 이진탐색트리 BST
    * 8, 4, 9, 2, 10, 5, 11, 1, **6, 13**, 3, 14, 7

  * 후위 순회(post-order)

    * 왼쪽 하위트리, 오른쪽 하위트리 방문 후, 루트 방문
    * 왼쪽 자식 => 오른쪽 자식 => 루트
    * 8, 9, 4, 10, 11, 5, 2, 13, 6, 14, 7, 3, 1

  * 레벨 순회(level-order)

    * 루트부터 계층별로 방문

    * BFS

    * 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14

    * cf. 레벨 

      →   각 층에 값을 매김

      →   루트는 0부터 시작하고, 최고 레벨 = 트리 높이

  

### 2. BST(Binary Search Tree; 이진 탐색 트리)

* 데이터 저장 규칙 & 특징

  * 각 노드의 자식이 0개 ~ 2개
  * 이진 탐색 트리의 노드에 저장된 키는 유일(중복 X)
    * 검색이 목적인 자료구조이기 때문에 중복 값을 넣어 검색속도 느리게 할 필요 X
    * 차라리 노드에 count값을 넣어 처리하는 것이 효율적
  * 왼쪽 자식 노드 키 < 부모 노드 키 < 오른쪽 자식 노드 키
    * 중위 순회로 정렬 순서를 읽음
  * 왼쪽과 오른쪽 서브트리도 이진 탐색 트리

* 사용 이유

  * 효율적인 탐색과 자료 삽입/삭제를 위해

    * 이진탐색 + 연결리스트의 장점을 합침

      →   이진 탐색: 탐색에 소요되는 시간 복잡도 O(log(n)) 

      →   연결리스트: 삽입, 삭제 시간복잡도 O(1)

* 시간복잡도

  * 검색/삽입/삭제 시간은 트리의 깊이에 비례
  * 균등 트리
    * O(log(N))
  * 편향 트리
    * O(n)
    * 계속 큰 것만 혹은 작은 것만 들어올 경우 발생
      * 해결 방법 : Red Black Tree

* 삭체 3가지 Case

  * 리프 노드 => 그냥 삭제
  * 자식 1개인 노드 => 지워진 노드에 자식 올리기
  * 자식 2개인 노드 => 왼쪽 자식 트리 중 최대 값 or 오른쪽 자식 트리중 최소값 올리기

* 이진 트리 종류

  * 포화 이진 트리(Perfect Binary Tree)

    * 모든 레벨이 다 찬 트리 (노드 갯수 = 2*트리 높이 - 1)
    * 리프 노드들 레벨 same
    * 완전 이진 트리의 종류

  * 완전 이진 트리(Complete Binary Tree)

    <img src="https://user-images.githubusercontent.com/70613905/163101984-dcaaa2a7-6893-4023-bd4e-1b4e986c6bbb.JPG" style="zoom:60%;" />

    * 마지막 레벨 지외한 모든 레벨이 다 채워진 트리
    * 마지막 레벨은 왼쪽부터 채워져야 함

  * 정 이진 트리(Full Binary Tree)

    * 모든 노드 자식이 0개 혹은 2개(1개 안됨)



### 3. Red-Black Tree (RBT)

* BST기반으로 하여, depth를 최소화해서 시간복잡도 줄인 자료구조

* 특징
  * BST 특징과 같음
  * Root Property(루트 조건)

    * 루트는 black
  * External Property

    * 모든 리프는 black

      →   여기서 리프노드는 모든 널 포인터가 NIL이라는 리프노드를 가리킨다

      →   따라서, NIL이라는 리프노드의 색이 black
  * Internal Property(내부 조건)

    * 노드가 red면, 그 노드의 자식은 black

      →   red 연속으로 나올 수 없다.

      →   블랙은 연속으로 가능
  * Depth Property(깊이 조건)

    * 루트에서 임의의 리프노드(NIL노드)에 이르는 경로에서 만나는 black 노드 수는 모두 같다

      →   이 특징이 트리의 균형을 맞춤

* 사용 이유
  * BST기반으로 하여, depth를 최소화해서 시간복잡도 줄임
  * 즉, 편향 트리가 되어 탐색 시간 복잡도가 O(n)이면 트리 사용 이유가 없어지기 때문에 이를 방지

* 시간복잡도
  * O(log(n))

* 삽입 과정

  * [알고리즘 ) Red-Black Tree (tistory.com)](https://zeddios.tistory.com/237)

  * 삽입되는 노드의 색은 red

    * black-depth를 유지하기 위하여

  * 새 노드를 삽입 시, 내부조건(red노드 자식은 black) 위배될 경우

    * 새 노드의 부모의 형제노드가 red일 경우

      →   recoloring 

      >1. 부모노드와 형제노드 색을 black으로 바꿈
      >2. 그 뒤 조부모 노드 색을 red로 바꿈

    * 새 노드의 부모의 형제노드가 black일 경우

      →   restructuring : rotation

      >1. 새 노드와 부모, 조부모 노드를 오름차순 정렬
      >2. 가운데 노드가 무조건 부모노드가 됨
      >3. 3개 노드로 이루어진 트리에서 가운데 노드를 빨강, 나머지 검정으로 칠함
      >
      >   ㆍ  이 과정은 다른 서브트리에 영향(= black depth) x, 따라서 1번만 restructuring하면 됨
      >
      >​	ㆍ  restructuring은 O(1)이지만 일단 새 노드가 들어가고, 들어갈 위치를 찾는 연산이 먼저 일어나기에 O(log(n))  


* 삭제 과정

  * 삭제할 노드가 red

    * 그냥 삭제

  * 삭제할 노드가 black

    * 이진 검색 트리 삭제 이용

    * 자리를 대체하는 노드 색을 black으로

      



### 4. 우선순위 큐

* 힙은 우선순위 큐를 위해 만들어진 구조
* 우선순위가 높은 데이터가 먼저 나감
* 사용 이유
  * 작업 스케줄링
  * 수치해석 계산



### 5. 힙(Heap)

* 여러 값 중 최대값과 최소값을 빠르게 찾도록 하는 완전 이진 트리

* 반정렬 상태

  * 부모노드가 자식노드보다 우선순위 높다
  * But, 형제노드 간 우선순위는 없음

* 중복 값 허용

  * 이진 탐색 트리는 불허

* 종류

  * 최대 힙(max heap)
    * 부모노드 키 >= 자식노드 키 인 완전 이진 트리
  * 최소 힙(min heap)
    * 부모노드 키 <= 자식노드 키 인 완전 이진 트리

* 구현

  * 힙을 저장하는 표준 자료 구조 = 배열
  * 구현을 쉽게하기 위해 배열 첫 인덱스 0은 사용 X
    * 노드 고유번호와 배열 index를 일치시켜 혼동 줄임
  * 특정위치 노드 번호는 새 노드가 추가되어도 변하지 않음 ?
  * 부모노드와 자식노드 관계
    * 왼쪽 자식 index = (부모 index * 2) + 1
    * 오른쪽 자식 index = (부모 index * 2) + 2
    * 부모 index = (자식 index - 1) // 2
    * 왜 ? 

* 삽입

  1. 새 원소를 힙의 마지막 노드에 삽입

  2. 새 노드가 부모노드보다 크면 swap (최대 힙)
  3. 크지 않을 때까지 swap 반복

* 삭제

  1. 루트 노드 삭제
  2. 힙의 마지막 노드를 루트에 가져옴
  3. 현재 루트와 왼쪽 자식 노드 비교하여 자식이 더 크면 Swap (heapify 과정 시작)
  4. 아니면 오른쪽 자식 노드와 swap
  5. 힙의 끝에 도달할 때까지 반복
