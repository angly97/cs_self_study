# 7. 이진탐색트리 개선 트리

> Red-Black Tree(RBT) / B Tree / B+ Tree



### 1. Red-Black Tree (RBT)

* BST기반으로, 깊이를 최소화해서 시간복잡도 줄인 자료구조

* 특징

  * BST 특징과 같음

    * 각 노드의 자식이 0개 ~ 2개

    * 이진 탐색 트리의 노드에 저장된 키는 유일 (중복 X)

      →   검색이 목적인 자료구조이기 때문에 중복 값을 넣어 검색속도 느리게 할 필요 X

      →   차라리 노드에 count값을 넣어 처리하는 것이 효율적

    * 왼쪽 자식 노드 키 < 부모 노드 키 < 오른쪽 자식 노드 키

      →   중위 순회로 정렬 순서를 읽음

  * 루트 조건 (Root Property)

    * 루트는 black

  * 외부 조건 (External Property)

    * 모든 리프는 NIL(null인 클래스)이며, black

  * 내부 조건 (Internal Property)

    * 노드가 red면, 그 자식은 black

      →   red 연속으로 나올 수 없고, black은 연속으로 가능

  * 깊이 조건 (Depth Property)

    * 루트에서 임의의 리프노드(NIL)까지 가는 경로에서 만나는 black 노드 수는 모두 같다

      →   이 특징이 트리의 균형을 맞춤

* 사용 이유

  * 깊이를 최소화해서 시간복잡도 줄임
  
* 단점

  * 하나의 노드에 1개 데이터만 저장한다는 점

    * 이 때문에, 탐색 시 속도가 느려짐
    * 찾는 데이터 나올 때까지 자식노드로 내려가는데 노드 수가 많아 찾는 노드도 많아짐

      * 노드와 노드 사이는 참조 포인터라서, 주소 알아내는 부가 연산 필요
      * B Tree는 노드 안에 배열 구조라서, 주소 알아내는 연산없이 실제 메모리에 빠른 접근 가능


* 시간복잡도

  * 모든 경우에서, O(log(n))

* 삽입 과정

  * [알고리즘 ) Red-Black Tree (tistory.com)](https://zeddios.tistory.com/237)

  * 삽입되는 노드의 색은 red

    * black-depth를 유지하기 위하여

  * 새 노드를 적절한 위치에 삽입 시, 내부조건(red의 자식은 black) 위배할 경우

    * 삼촌노드(부모의 형제노드)가 red일 경우

      →   recoloring 

      >1. 삼촌노드와 부모노드를 black으로 바꿈
      >2. 그 뒤 조부모(할머니)노드 색을 red로 바꿈

    * 삼촌노드가 black일 경우

      →   restructuring : rotation

      >1. 새 노드와 부모, 조부모 노드를 오름차순 정렬
      >2. 가운데 노드가 무조건 부모노드가 되고, 나머지 2개가 자식 노드가 됨
      >3. 부모를 red, 자식들을 black으로 처리
      >
      > ​	ㆍ  restructuring은 O(1)이지만 일단 새 노드가 들어가고, 들어갈 위치를 찾는 연산이 먼저 일어나기에 O(log(n))  


* 삭제 과정

  * 삭제할 노드가 red

    * 그냥 삭제
  * 삭제할 노드가 black

    * 이진 검색 트리 삭제 이용
    * 자리를 대체하는 노드 색을 black으로

  

### 2. B Tree

![image-20220415215820269](https://user-images.githubusercontent.com/70613905/163576595-b749fcc5-1551-4b34-8870-cb33247a9a5f.png)

* BST에서 발전되어 모든 리프노드들의 레벨이 같도록 하는 트리

* 이진트리보다 더 많은 자식을 가지게 하여, 최대 M개 자식을 갖는 B트리를 M차 B트리

* 특징

  * 한 노드의 키(즉, 자료)가 x개 => 자식노드 수는 x+1개
  * 자료는 정렬된 상태 (BST 특징)
  * 입력 자료는 중복 X (BST 특징)
  * 노드의 한 자료의 왼쪽 서브트리는 자료보다 작은 값, 오른쪽은 큰 값들
  * 루트 노드는 적어도 2개 이상 자식 가짐
  * 나머지 노드는 균등트리를 만들기 위해, M//2 ~ M개 자식 가짐
  * 외부노드로 가능 경로 길이는 모두 같다 = 리프노드는 모두 같은 레벨

* 사용 이유

  * 이진검색트리의 균형이 맞지 않으면 검색이 비효율적이라

  * 대량 데이터 처리 시, 하나의 노드에 여러 데이터가 들어가는 건 장점

    * 왜냐면, 대량의 데이터는 메모리보다 블럭 단위로 입출력하는 하드디스크에 저장해야해서

    * 왜 블럭을 이용하는 게 좋냐면, 
  한 블럭이 1024바이트일 때, 2바이트를 읽으나 1024바이트를 읽으나 같은 비용 발생 => 따라서 한 노드에 1024바이트를 전부 채우면 효율적
  
* 사용되는 곳

  * 데이터베이스, 파일 시스템 등 대용량 데이터 처리 시
    * 트리 내 모든 데이터 정렬된 상태
    * 같은 노드 내 자료들은 배열로 저장되어, 포인터 접근 방식이 적기 때문에, 많은 데이터 있어도 속도 빠름
    * 데이터 탐색, 삽입, 삭제에도 늘 복잡도 O(log(n))
    * [데이터베이스 인덱스는 왜 'B-Tree'를 선택하였는가 :: 이뇽의세상 (tistory.com)](https://helloinyong.tistory.com/296)

* 시간복잡도

  * 늘 O(log(n))



### 3. B+ Tree

![B+트리](https://user-images.githubusercontent.com/70613905/163576600-4889c230-47a1-46fe-99e5-46da7c7afe05.JPG)

* B트리와 유사하지만 비단말노드는 인덱스역할만 함 
  (즉, 리프노드 찾기 위한 인덱스 부분 + 리프노드(데이터 순차적으로 연결리스트에 저장됨))
* B트리와의 차이
  * 리프노드에 모든 키, 데이터 있음
    * B트리는 리프노드가 아니라 각자 키마다 데이터를 가졌음
    * 리프노드에 인덱스 부분 키 값이 한 번 더 등장 (자료 중복)
    * 데이터 삽입 삭제도 리프노드에서만 이루어짐
  * 리프노드가 연결리스트
    * B트리는 옆의 리프노드 검사 시, 다시 루트부터 검사
    * B+트리는 리프노드에서 선형검사 => 시간복잡도 감소
  * 리프노드 부모 키 <=  자식 리프노드의 첫번째 키
    
    ​	<img src="https://user-images.githubusercontent.com/70613905/172616778-9197b3b7-c666-4a15-82a3-670c79c91823.JPG" alt="image-20220608213041270" style="width:70%;" />
* 사용 이유
  * 리프노드가 연결리스트로 전부 이어져 있어서, 리프노드에서 선형탐색이 가능하기 때문에 => 시간복잡도 감소
  * cf. 단점
    * B 트리는 best case에서 끝낼 수 있지만, B+트리는 무조건 리프노드까지 가야함
* 사용되는 곳
  * 실제로 데이터베이스
* 시간복잡도
  * O(log(n))
