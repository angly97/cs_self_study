# 7. 이진탐색트리 개선 트리

> Red-Black Tree(RBT) / B Tree / B+ Tree

### 1. Red-Black Tree (RBT)

* BST기반으로 하여, depth를 최소화해서 시간복잡도 줄인 자료구조

* 특징

  * BST 특징과 같음

    * 각 노드의 자식이 0개 ~ 2개

    * 이진 탐색 트리의 노드에 저장된 키는 유일(중복 X)

      →   검색이 목적인 자료구조이기 때문에 중복 값을 넣어 검색속도 느리게 할 필요 X

      →   차라리 노드에 count값을 넣어 처리하는 것이 효율적

    * 왼쪽 자식 노드 키 < 부모 노드 키 < 오른쪽 자식 노드 키

      →   중위 순회로 정렬 순서를 읽음

    * 왼쪽과 오른쪽 서브트리도 이진 탐색 트리

  * Root Property(루트 조건)

    * 루트는 black

  * External Property(외부 조건)

    * 모든 리프는 black

      →   여기서 리프노드는 모든 널 포인터가 NIL이라는 리프노드를 가리킨다

      →   따라서, NIL이라는 리프노드의 색이 black

  * Internal Property(내부 조건)

    * 노드가 red면, 그 노드의 자식은 black

      →   red 연속으로 나올 수 없다.

      →   블랙은 연속으로 가능

  * Depth Property(깊이 조건)

    * 루트에서 임의의 리프노드(NIL노드)에 이르는 경로에서 만나는 black 노드 수는 모두 같다

      →   이 특징이 트리의 균형을 맞춤

* 사용 이유

  * BST기반으로 하여, depth를 최소화해서 시간복잡도 줄임
  * 즉, 편향 트리가 되어 탐색 시간 복잡도가 O(n)이면 트리 사용 이유가 없어지기 때문에 이를 방지

* 단점


  * 하나의 노드에 1개 데이터

    * 탐색 시 속도가 느려짐
    * 찾는 데이터 나올 때까지 자식노드로 내려가는데 노드 수가 많아 찾는 노드도 많아짐

      * 노드와 노드 사이는 참조 포인터(주소 알아내는 부가 연산 필요)
      * B는 노드 안에 배열 구조(주소 알아내는 연산 필요 X)

* 시간복잡도

  * O(log(n))

* 삽입 과정

  * [알고리즘 ) Red-Black Tree (tistory.com)](https://zeddios.tistory.com/237)

  * 삽입되는 노드의 색은 red

    * black-depth를 유지하기 위하여

  * 새 노드를 삽입 시, 내부조건(red노드 자식은 black) 위배될 경우

    * 새 노드의 부모의 형제노드가 red일 경우

      →   recoloring 

      >1. 부모노드와 형제노드 색을 black으로 바꿈
      >2. 그 뒤 조부모 노드 색을 red로 바꿈

    * 새 노드의 부모의 형제노드가 black일 경우

      →   restructuring : rotation

      >1. 새 노드와 부모, 조부모 노드를 오름차순 정렬
      >2. 가운데 노드가 무조건 부모노드가 됨
      >3. 3개 노드로 이루어진 트리에서 가운데 노드를 빨강, 나머지 검정으로 칠함
      >
      >  ㆍ  이 과정은 다른 서브트리에 영향(= black depth) x, 따라서 1번만 restructuring하면 됨
      >
      >​	ㆍ  restructuring은 O(1)이지만 일단 새 노드가 들어가고, 들어갈 위치를 찾는 연산이 먼저 일어나기에 O(log(n))  


* 삭제 과정

  * 삭제할 노드가 red

    * 그냥 삭제
  * 삭제할 노드가 black

    * 이진 검색 트리 삭제 이용
    * 자리를 대체하는 노드 색을 black으로

  

### 2. B Tree

![image-20220415215820269](C:\Users\angly\AppData\Roaming\Typora\typora-user-images\image-20220415215820269.png)

* BST에서 발전되어 모든 리프노드들의 레벨이 같도록 하는 트리

* 이진트리를 확장하여 더 많은 자식을 가지게 하여 최대 M개 자식을 갖는 B트리를 M차 B트리

* 특징

  * 노드의 키(자료)가 x개 => 자식 x+1개
  * 자료는 정렬된 상태
  * 입력 자료는 중복 X
  * 노드의 자료 Dk의 왼쪽 서브트리는 Dk보다 작은 값, 오른쪽은 큰 값들
  * 루트 노드는 적어도 2개 이상 자식 가짐
  * 나머지 노드는  M//2 ~ M개 자식 가짐
  * 외부노드로 가능 경로 길이는 모두 같다 = 리프노드는 모두 같은 레벨

* 사용 이유

  * 이진검색트리의 균형이 맞지 않으면 검색이 비효율적이라

  * 대량 데이터 처리 시, 하나의 노드에 여러 데이터가 들어가는 건 장점

    * 대량의 데이터는 메모리보다 블럭 단위로 입출력하는 하드디스크/SSD에 저장해야해서

    * ex. 한 블럭이 1024바이트면, 2바이트를 읽으나 1024바이트를 읽으나 같은 비용 발생

      ​	따라서 한 노드에 1024바이트를 전부 채우면 효율적

* 사용되는 곳

  * 데이터베이스, 파일 시스템
    * 트리 내 모든 데이터 정렬된 상태
    * 포인터 접근 방식이 적어, 매우 많은 데이터 있어도 속도 이슈 적음
    * 데이터 탐색, 삽입, 삭제에도 늘 복잡도 O(log(n))
    * [데이터베이스 인덱스는 왜 'B-Tree'를 선택하였는가 :: 이뇽의세상 (tistory.com)](https://helloinyong.tistory.com/296)

* 시간복잡도

  * O(log(n))



### 3. B+ Tree

![image-20220415215655502](C:\Users\angly\AppData\Roaming\Typora\typora-user-images\image-20220415215655502.png)

* B트리와 유사하지만 비단말노드는 인덱스역할만 함 (즉, 리프노드 찾기 위한 인덱스 부분 + 리프노드(데이터 순차적으로 연결리스트))
* B트리와의 차이
  * 리프노드에 모든 키, 데이터 있음
    * B트리는 리프노드가 아니라 각자 키마다 데이터를 가졌음
    * 리프노드에 인덱스 부분 키 값이 한 번 더 등장 (자료 중복)
    * 데이터 삽입 삭제도 리프노드에서만 이루어짐
  * 리프노드가 연결리스트
    * B트리는 옆의 리프노드 검사 시, 다시 루트부터 검사
    * B+트리는 리프노드에서 선형검사 => 시간복잡도 감소
  * 리프노드 부모 키 <=  리프노드의 첫번째 키
    * 자료 중복 가능
* 사용 이유
  * 리프노드가 연결리스트
    * 리프노드에서 선형검사 => 시간복잡도 감소
  * cf. 단점
    * B 트리는 best case에서 끝낼 수 있지만, B+트리는 무조건 리프노드까지 가야함
* 사용되는 곳
  * 실제로 데이터베이스
* 시간복잡도
  * O(log(n))