# 7. 이진탐색트리 개선 트리

> Red-Black Tree(RBT) / B Tree / B+ Tree
>
> : BST에서 발전되어 모든 리프노드들의 레벨이 같도록 하는 트리



### 1. Red-Black Tree (RBT)

* 특징

  * BST 특징과 같음

    * 각 노드의 자식이 0개 ~ 2개

    * 노드에 저장된 키는 유일 (**중복 X**)

      →   검색이 목적인 자료구조이기 때문에 중복 값을 넣어 검색속도 느리게 할 필요 X

      →   중복이 있다면, 노드에 count값을 넣어 증가시킴

    * 왼쪽 자식 노드 키 < 부모 노드 키 < 오른쪽 자식 노드 키

      →   중위 순회로 정렬 순서를 읽음

  * 루트 조건 (Root Property)

    * 루트는 black

  * 외부 조건 (External Property)

    * 모든 리프는 NIL(null인 클래스)이며, black

  * 내부 조건 (Internal Property)

    * red인 노드의 자식은 black

      > 즉, 레드는 연속으로 나올 수 없고, 블랙은 연속으로 가능

  * 깊이 조건 (Depth Property)

    * 루트에서 임의의 리프노드(NIL)까지 가는 경로에서 만나는 black 노드 수는 모두 같다

      →   이 특징이 트리의 균형을 맞춤

* 사용 이유

  * 깊이를 최소화해서 시간복잡도 줄임

* 단점

  * **하나의 노드에 1개 데이터만 저장한다는 점**
    * 이 때문에, 깊이가 깊어져서 탐색 속도 느려짐
  * 노드와 노드 사이는 참조 포인터라서, 주소 알아내는 부가 연산 필요
    * B Tree는 노드 안에 배열 구조라서, 주소 알아내는 연산없이 실제 메모리에 빠른 접근 가능


* 시간복잡도

  * 모든 경우에서, O(log(n))

* 삽입 과정

  * [알고리즘 ) Red-Black Tree (tistory.com)](https://zeddios.tistory.com/237)

  * 삽입되는 노드의 색은 red

    * black-depth를 유지하기 위하여

  * 새 노드를 적절한 위치에 삽입 시, 내부조건(red의 자식은 black) 위배할 경우

    * 삼촌노드(부모의 형제노드)가 red일 경우, 다시 칠하는 과정을 거칩니다.

      →   recoloring 

      >1. 삼촌노드와 부모노드를 black으로 바꿈
      >2. 그 뒤 조부모(할머니)노드 색을 red로 바꿈

    * 삼촌노드가 black일 경우, 재배치를 해줍니다.

      →   restructuring : rotation

      >1. 새 노드와 부모, 조부모 노드를 오름차순 정렬
      >2. 가운데 노드가 무조건 부모노드가 되고, 나머지 2개가 자식 노드가 됨
      >3. 부모를 red, 자식들을 black으로 처리
      >
      > ​	ㆍ  restructuring은 O(1)이지만 일단 새 노드가 들어가고, 들어갈 위치를 찾는 연산이 먼저 일어나기에 O(log(n))  


* 삭제 과정

  * 삭제할 노드가 red

    * 그냥 삭제
  * 삭제할 노드가 black

    * 이진 검색 트리 삭제 이용
    * 자리를 대체하는 노드 색을 black으로

  

### 2. B Tree

![image-20220415215820269](https://user-images.githubusercontent.com/70613905/163576595-b749fcc5-1551-4b34-8870-cb33247a9a5f.png)

* 이진트리보다 더 많은 자식을 가지게 하며, 최대 M개 자식을 갖는 B트리를 M차 B트리
* 특징

  * 리프노드는 모두 같은 레벨
  * **루트 노드는 적어도 2개 이상 자식 가짐**
  * 나머지 노드는 균등트리를 만들기 위해, M//2 ~ M개 자식 가짐
  * 한 노드안에 키. 즉 **자료가 x개일 때 => 자식노드 수는 x+1개**
  * 자료는 **정렬된 상태이며, 중복 X**
  * 노드의 한 자료의 왼쪽 서브트리는 자료보다 작은 값, 오른쪽은 큰 값들
* 사용 이유

  * 트리의 균형을 맞춰, 깊이를 최소화하여 검색 시간 최소화

  * 대량 데이터 처리 시, 하나의 노드에 많은 데이터를 배열로 저장하는 것이 좋아서

    * 왜냐면, 같은 양을 갖더라도, 한 노드에 자료가 여러개이므로, **깊이도 낮고, 자식 노드로 내려가기 위한 포인터 연산도 적음**

* 사용되는 곳

  * 데이터베이스, 파일 시스템 등 대용량 데이터 처리 시
    * 트리 내 모든 데이터 정렬된 상태
    * 같은 노드 내 자료들은 배열로 저장되어, 포인터 접근 방식이 적기 때문에, 속도 빠름
    * 데이터 탐색, 삽입, 삭제에도 늘 복잡도 O(log(n)) 
    * [데이터베이스 인덱스는 왜 'B-Tree'를 선택하였는가 :: 이뇽의세상 (tistory.com)](https://helloinyong.tistory.com/296)
* 시간복잡도

  * 늘 O(log(n))
  * 한 노드 내 배열 길이는 상수개라서 시간복잡도에서 무시 가능



### 3. B+ Tree

![B+트리](https://user-images.githubusercontent.com/70613905/163576600-4889c230-47a1-46fe-99e5-46da7c7afe05.JPG)

* B트리와 유사하지만, 리프노드 찾기 위한 인덱스 부분 + 리프노드로 이루어짐

* 리프노드에는 데이터 순차적으로 연결리스트에 저장됨

* B트리와의 차이
  * 리프노드에 모든 키, 데이터 있음
    * B트리는 리프노드가 아니라, 모든 노드마다 키값 데이터를 가졌음
    * **B+는 그렇지 않아서, 데이터 삽입 삭제도 리프노드에서만 이루어짐**
  
  * 자료 중복됨
  
    * 리프노드에 인덱스 부분 키 값이 한 번 더 등장
  
  * 리프노드가 연결리스트
    * B트리는 옆의 리프노드 검사 시, 다시 루트부터 검사
    * B+트리는 리프노드에서 선형검사 => 시간복잡도 감소
  
  * 리프노드 부모 키 <=  자식 리프노드의 첫번째 키
  
    ​	<img src="https://user-images.githubusercontent.com/70613905/172616778-9197b3b7-c666-4a15-82a3-670c79c91823.JPG" alt="image-20220608213041270" style="width:70%;" />
  
* 사용 이유
  * 리프노드가 연결리스트로 전부 이어져 있어서, 리프노드에서 선형탐색이 가능하기 때문에 => 시간복잡도 감소
  * cf. 단점
    * **B 트리는 best case에서 끝낼 수 있지만, B+트리는 무조건 리프노드까지 가야함**
  
* 사용되는 곳
  * 관계형 데이터베이스 (ex. MySQL에서 쓰는 DB인, Inno DB(이노 DB))
  
    * [[데이터베이스\]B tree가 뭐죠? (tistory.com)](https://fierycoding.tistory.com/78)
  
    * B Tree가 아니라 B+ 사용하는 이유
  
      > * B Tree는 모든 노드에서 키값을 저장하는데, B+ Tree는 리프노드가 아닌 노드는 키만 저장해서, 남는 공간에 키를 끼워 넣음으로써 트리 높이를 더 낮춤
      >
      > * B Tree는 범위 탐색할 때, 옆의 리프노드도 검사해야할 경우, 다시 루트부터 검사
      >
      >   →   B+ Tree는 리프노드에서 선형 탐색하기 때문에, 루트에서 탐색하는 것이 적음
      >
      > * B Tree는 노드 삽입/삭제 마다, 트리 균형 유지하는 작업이 필수적이기 때문에 깊이가 깊어질수록, 오버헤드 커짐
      >
      >   →   B+ Tree는 삽입/삭제가 리프노드의 연결리스트에서만 이루어져서 비교적 간단
  
* 시간복잡도
  * O(log(n))
