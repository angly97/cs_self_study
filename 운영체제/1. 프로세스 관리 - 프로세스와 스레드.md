# 1. 프로세스 관리 - 프로세스와 스레드

> 운영체제(OS, 커널)란
>
> * 하드웨어와 소프트웨어 제어 & 응용 프로그램과 하드웨어 사이의 인터페이스
> * 시스템 자원과 동작을 관리하는 소프트웨어
> * 프로세스 관리, 저장장치 관리, 네트워킹, 사용자 관리, 디바이스 드라이버 등

>프로세스 관리란
>
>* 응용 프로그램 관리
>
>* CPU(프로세서) 스케줄링 관리
>
>  * 현재 CPU를 점유할 프로세스 결정하여 CPU 할당
>  * 이 프로세스 간 공유 자원 접근과 통신 관리



### 1. 프로세스 & 스레드

* 프로세스(Process)

  * 디스크로부터 메모리로 적재되어 실행중인 프로그램

    * 프로그램이 CPU에 의해 실행됨 => 프로세스가 생성되고, 메모리에 프로세스 주소 공간 할당 됨 => 이 프로세스 데이터들이 PCB에 저장

  * CPU, 파일, 메모리 등을 할당 받을 수 있음

  * 프로세스의 주소공간

    * 가상메모리 혹은 논리적 메모리(Logical memory)

    * 구역이 나뉜 이유

      →   최대한 데이터를 공유하여 메모리 사용을 줄이기 위해

      →   Code는 같은 프로그램 자체에서 모두 같은 내용이기에 따로 관리

      →   Stack, Data는 스택구조를 활용하고, 전역 변수 공유를 위해 분리하여 관리

      >Stack : LIFO 특성으로 재귀함수 등에서 스택 활용
      >
      >Data : 함수들이 공용으로 사용하는 전역변수

    * Code 

      →   사용자가 작성한 프로그램 코드

      →   프로그램 명령

    * Data

      →   프로그램이 사용하는 전역변수, 정적(static)변수, 배열 등

      →   초기화 된 데이터는 data 영역에 저장 (런타임 전 초기화)

      →   초기화 x 데이터는 bss 영역에 저장 (런타임 이후 초기화)

    * Heap

      →   프로세스 실행 중에 동적 할당되는 메모리 (new(), malloc() 등)

      →   프로그래머가 동적으로 사용하는 공간

    * Stack

      →   지역변수, 매개변수, 리턴 값

      →   임시 메모리 영역

      →   크기 제한적이기 때문에 재귀함수를 너무 많이 부를 경우 stack overflow

  * 프로세스 제어 블록(Process Control Block, PCB)

    * 프로세스의 중요 정보 저장하는 OS 자료구조

    * OS는 프로세스 관리를 위해 프로세스 생성과 동시에 PCB 생성

    * 프로세스 전환이 되면 CPU를 반환하는데, 이때 작업 진행상황이 PCB에 저장

    * 다시 CPU할당 받으면 PCB에 저장된 내용을 불러와 이전 종료시점부터 다시 작업

    * PCB들은 연결 리스트로 관리됨

      →   삽입/삭제 용이

      →   프로세스 생성 시 PCB가 생성되고, 완료 시 제거 됨

    * 저장되는 정보

      →   프로세스 식별자(Process ID; PID) : 프로세스 식별변호

      →   프로세스 상태 : new, ready, running, waiting, terminated 등

      →   프로그램 카운터(PC) : 프로세스가 다음에 실행할 명령어 주소

      →   CPU 레지스터

      →   CPU 스케줄링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등

      →   메모리 관리 정보 : 페이지 테이블나 세그먼트 테이블 등

      →   입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록

      →   어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등

* 스레드(Thread)

  * 프로세스 실행 단위

  * 주소공간 할당 방식

    * Stack만 따로 할당받고, 나머지 영역(Code, Data, Heap)은 다른 스레드와 공유

    * PC 레지스터가 독립적으로 할당되는 이유

      →   PC값은 스레드가 명령어의 어디까지 수행하였는지 나타냄

      →   수행 도중 CPU 할당을 넘겼을 때, 어느 부분까지 수행하였는지 기억할 필요 있음

    * Stack만 독립적인 이유

      →   스레더는 프로세스 작업을 독립적으로 실행하기 때문에, 함수 호출 시 전달되는 인자, 리턴값, 함수 내 변수 등을 독립적인 공간에 저장

    * 공용하는 이유

      →   다른 스레드로 컨텍스트 스위칭 시, 다음 스레드에서도 사용될 자원 생성의 중복을 줄여 성능 향상

* cf. 문맥 전환/컨텍스트 스위칭(Context switching)

  * 실행중인 프로세스나 스레드가 변경될 때, 그 상태 정보를 저장 & 복원하는 과정
  * 동작 중인 프로세스/스레드가 대기하면서 해당 프로세스 상태 보관 & 대가하던 다음 프로세스가 동작하면서 이전에 보관했던 상태 복구
  * 프로세스는 스레드와 달리 서로 독립된 메모리 영역을 사용하므로, 무거운 작업 진행 시 오베헤드 발생 가능성



### 2. 멀티 프로세스 & 멀티 스레드& 멀티 코어

* 멀티 프로세스

  * 여러 프로세스가 각각 독립된 메모리 영역으로 있는 경우

  * 장단점

    * 장점

      →   한 프로세스가 문제 생겨도 다른 프로세스에 영향 x

    * 단점

      →   많은 메모리 공간 & CPU 시간 차지

  * 예. 크롬

    * 여러 탭을 띄웠을 때 한 탭에서 오류나도 다른 탭 유지

* 멀티 스레드

  * 한 프로세스 내 여러 스레드 구성하여, 여러 작업 처리

  * 스레드들이 공유 메모리를 통해 다수 작업을 동시에 처리

  * 장단점

    * 장점

      →   적은 메모리 공간 차지

      →   문맥전환이 빠름

    * 단점

      →   자원 공유하기 때문에 하나의 스레드 종료 시, 전체 스레드 종료될 수 있음

      →   다른 스레드가 사용한 영역에 접근하여 엉뚱한 값을 RW하는 문제

      →   동기화하여 해결 : 임계영역(Critical section)

  * 예. 인터넷 익스플로어

    * 오류가 나면 모든 텝이 오류남

* 멀티 코어

  * 병렬처리(Parallelism)

    * CPU 내 코어들이 동시에 각각 하나 프로세스 작업을 같이 수행

  * 싱글 코어

    * 동시성(Concurrency)

      →   하나의 코어에서 여러 프로세스/스레드가 빠르게 번갈이 진행되어 동시에 진행하는 것 처럼 보임

    

### 2. 프로세스 관리

* 

  

* 프로세스, 스레드

* 스케줄링

* 동기화

* IPC통신



### 3. 저장장치 관리

* 메인메모리 & 하드디스크, NAND 관리

* 1차 저장장치(Main memory)

  * 프로세스에 할당하는 메모리 영역 할당 & 해제
  * 각 메모리 영역 간 침범 방지
  * 메인 메모리 효율 높이기 위한 가상 메모리 기능

* 2차 저장장치(HDD, NAND Flash memory 등)

  * 파일 형식 데이터 저장
  * 파일 데이터 관리를 위한 파일 시스템을 OS에서 관리

  

* 메모리 관리

* 가상 메모리

* 파일 시스템



### 4. 네트워킹

* TCP/IP 기반 인터넷에 연결하거나, 응용 프로그램이 네트워크 사용하려면 OS가 네트워크 프로토콜 지원해야 함
* 즉, 사용자와 컴퓨터 하드웨어 사이에서, 하드웨어 관리&제어하여 소프트웨어적으로 관리
* TCP/IP
* 기타 프로토콜



### 5. 사용자 관리

* 한 컴퓨터를 여러 사람이 계정을 만들어 사용할 경우, 각 계정 관리 필요
  * 사용자 별 프라이버시 보안
  * 접근 권한 지정
* 계정 관리
* 접근권한 관리



### 6. 디바이스 드라이버

* OS가 하드웨어를 인식하고 관리하기 위해 하드웨어를 추상화하는 계층
* 순차접근 장치
* 임의접근 장치
* 네트워크 장치

