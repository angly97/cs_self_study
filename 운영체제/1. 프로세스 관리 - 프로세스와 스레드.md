# 1. 프로세스와 스레드

> 운영체제(OS, 커널)
>
> * 하드웨어와 소프트웨어를 제어하는 인터페이스
> * 시스템 자원과 동작을 관리하는 소프트웨어
> * 프로세스 관리, 저장장치 관리, 네트워킹, 사용자 관리, 디바이스 드라이버 등

>프로세스 관리
>
>* 응용 프로그램 관리
>
>* CPU(프로세서) 스케줄링 관리
>
>  * 현재 CPU를 점유할 프로세스 결정하여 CPU 할당
>  * 이 프로세스 간 공유 자원 접근과 통신 관리



### 1. 프로세스 & 스레드

* 프로세스(Process)

  * 디스크로부터 메모리로 적재되어 실행중인 프로그램

    *  CPU가 프로그램 실행 => 프로세스가 생성되고, 메모리에 프로세스 주소 공간 할당 됨 => 이 프로세스 데이터들이 PCB에 저장

  * CPU, 파일, 메모리 등을 할당 받을 수 있음

  * 프로세스의 주소공간 : User 영역

    * 프로그램이 동작하기 위해 사용되는 메모리 공간

    * 물리적 영역으로의 접근 제한이 있고, 접근 가능한 메모리도 제한적

    * 구역이 나뉜 이유(코드 영역, 데이터 영역, 스택 및 힙 영역)

      →   최대한 데이터를 공유하여 메모리 사용을 줄이기 위해

      →   Code는 같은 프로그램에선, 모두 같은 내용이기에 따로 관리

      →   Stack, Data는 스택구조를 활용하고, 전역 변수를 공유하기 위해 따로 관리

      >Stack : LIFO 특성으로 재귀함수 등에서 스택 활용
      >
      >Data : 함수들이 공용으로 사용하는 전역변수

    * Code 

      →   사용자가 작성한 프로그램 코드

      →   프로그램 명령

    * Data

      →   프로그램이 사용하는 전역변수, 정적(static)변수, 배열 등

      > 초기화 된 데이터는 data 영역에 저장 (런타임 전 초기화)
      >
      > 초기화 x 데이터는 bss 영역에 저장 (런타임 이후 초기화)

    * Heap

      →   프로세스 실행 중에 동적 할당되는 메모리 (new(), malloc() 등)

      →   즉, 프로그래머가 동적으로 사용하는 공간

    * Stack

      →   지역변수, 매개변수, 리턴 값같은 임시 메모리 영역

      →   크기에 제한이 있어 재귀함수를 너무 많이 부를 경우 stack overflow

  * 커널 영역

    * 프로세스의 메모리 공간 중, 유저 영역을 제외한 나머지 영역

    * 운영체제를 실행시키기 위한 메모리 공간, 커널이 위치

      > 운영체제가 실행되기 위해서는 운영체제 역시 메모리에 올라가야 하고, 또 일반 프로그램처럼 변수 선언도 하고 메모리를 동적 할당하기도 한다.
    >
      > 이렇게 **운영체제라는 하나의 소프트웨어를 실행시키기 위한 메모리 공간**

    * 메모리 & CPU같은 하드웨어도 접근 가능

  * 프로세스 제어 블록(Process Control Block, PCB)

    * 프로세스의 중요 정보 저장하는 OS 자료구조

    * OS는 프로세스 관리를 위해 프로세스 생성과 동시에 PCB 생성

    * 프로세스 전환이 되면 CPU를 반납하는데, 이때 작업 진행상황이 PCB에 저장

    * 다시 CPU할당 받으면 PCB를 통해 이전 중단시점부터 다시 작업

    * PCB들은 연결 리스트로 관리됨

      →   삽입/삭제 용이 (프로세스 생성 시 PCB가 생성되고, 완료 시 제거 됨)

    * 저장되는 정보

      →   프로세스 식별자(Process ID; PID) : 프로세스 식별변호

      →   프로세스 상태 : new, ready, running, waiting, terminated 등

      →   프로그램 카운터(PC) : 프로세스가 다음에 실행할 명령어 주소

      →   CPU 레지스터

      →   CPU 스케줄링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등

      →   메모리 관리 정보 : 페이지 테이블, 세그먼트 테이블 등

      →   입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록

      →   어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등

* 스레드(Thread)

  * 프로세스 실행 단위

  * 주소공간 할당 방식

    * Stack만 따로 할당받고, 나머지 영역(Code, Data, Heap)은 다른 스레드와 공유

    * PC 레지스터가 독립적으로 할당되는 이유

      →   PC값은 스레드가 명령어의 어디까지 수행하였는지 나타냄

      →   수행 도중 CPU 할당을 넘겼을 때, 각 스레드의 어느 부분까지 수행하였는지 기억할 필요 있음

    * Stack만 독립적인 이유

      →   스레드는 프로세스를 독립적으로 실행하기 때문에, 인자, 지역변수, 리턴값 등도 독립적인 공간에 저장

    * 공용하는 이유

      →   컨텍스트 스위칭 시, 다음 스레드에서도 사용될 자원 생성의 중복을 줄여 성능 향상

* cf. 문맥 전환/컨텍스트 스위칭(Context switching)

  * 실행중인 프로세스나 스레드가 변경될 때, 그 상태 정보를 저장 & 복원하는 과정
  * 프로세스는 스레드와 달리 서로 독립된 메모리 영역을 사용하므로, 무거운 작업 진행 시 오버헤드 발생 가능성



### 2. 멀티 프로세스 & 멀티 스레드 & 멀티 코어

* 멀티 프로세스

  * 여러 프로세스가 각각 독립된 메모리 영역으로 있는 경우

  * 장단점

    * 장점

      →   한 프로세스가 문제 생겨도 다른 프로세스에 영향 x

    * 단점

      →   많은 메모리 공간 & CPU 시간 차지

  * 예. 크롬

    * 여러 탭을 띄웠을 때 한 탭에서 오류나도 다른 탭 유지

* 멀티 스레드

  * 한 프로세스 내 여러 스레드 구성하여, 여러 작업 처리

  * 스레드들이 공유 메모리를 통해 다수 작업을 동시에 처리

  * 장단점

    * 장점

      →   적은 메모리 공간 차지

      →   문맥전환이 빠름

    * 단점

      →   자원 공유하기 때문에 하나의 스레드 종료 시, 전체 스레드 종료될 수 있음

      →   다른 스레드가 사용한 영역에서 엉뚱한 값을 RW할 수 있음

      →   동기화하여 해결 : 임계영역(Critical section)

  * 예. 인터넷 익스플로어

    * 오류가 나면 모든 텝이 오류남

* 멀티 코어

  * 병렬처리(Parallelism)

    * CPU 내 코어들이 동시에 각각 하나 프로세스를 작업

  * 싱글 코어

    * 동시성(Concurrency)

      →   하나의 코어에서 여러 프로세스/스레드가 빠르게 번갈이 진행되어 동시에 진행하는 것 처럼 보임

