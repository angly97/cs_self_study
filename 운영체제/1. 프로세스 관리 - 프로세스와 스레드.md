# 1. 프로세스와 스레드

> 운영체제(OS, 커널)
>
> * 하드웨어와 소프트웨어를 제어하는 인터페이스
> * 시스템 자원과 동작을 관리하는 소프트웨어
> * 프로세스 관리, 저장장치 관리, 네트워킹, 사용자 관리, 디바이스 드라이버 등

>프로세스 관리
>
>* 응용 프로그램 관리. CPU(프로세서) 스케줄링 관리
> * **CPU 할당받을 Ready queue의 프로세스들의 우선순위 관리, 프로세스 간 공유자원을 관리합니다**



### 1. 프로세스 & 스레드

* 프로세스 (Process)

  * 디스크로부터 메모리로 적재되어 실행중인 프로그램

    *  CPU가 프로그램 실행하면 => 프로세스가 생성되고, 메모리에 프로세스 주소 공간 할당 됨 => 이 프로세스 데이터들이 PCB에 저장

  * CPU, 파일, 메모리 등을 할당 받을 수 있음

  * **프로세스의 주소공간 : User 영역**

    * 프로그램이 동작하기 위해 사용되는 메모리 공간

    * **물리적 영역으로의 접근 제한이 있고, 접근 가능한 메모리도 제한적**

    * 구역이 나뉜 이유 (코드 영역, 데이터 영역, 스택 및 힙 영역)

      →   최대한 데이터를 공유하여 메모리 사용을 줄이기 위해

      →   Code는 같은 프로그램에선, 모두 같은 내용이기에 따로 관리

      →   Stack은 스택구조나 지역변수를 활용하기 위해, data는 전역 변수를 공유하기 위해 따로 관리

    * Code 
    
      →   프로그램 코드, 프로그램 명령이 저장된 영역

    * Data

      →   프로그램이 사용하는 전역변수, 정적(static)변수, 배열 등을 위한 공간

      > 초기화 된 데이터는 data 영역에 저장 (런타임 전 초기화)
      >
      > 초기화 x 데이터는 bss 영역에 저장 (런타임 이후 초기화)
    * Stack
    
      →   지역변수, 매개변수, 리턴 값같은 임시 메모리 영역
    
      →   크기에 제한이 있어 재귀함수를 너무 많이 부를 경우 stack overflow
    
    * Heap
    
      →   프로세스 실행 중에 동적 할당되는 메모리 (new(), malloc() 등)
    
      →   즉, 프로그래머가 동적으로 사용하는 공간
    
  * 커널 영역
  
    * 프로세스의 메모리 공간 중, 유저 영역을 제외한 나머지 영역으로 커널이 위치
  
    * 운영체제를 실행시키기 위한 메모리 공간
  
      > 운영체제가 실행되기 위해서는 운영체제 역시 메모리에 올라가야 하고, 또 일반 프로그램처럼 변수 선언도 하고 메모리를 동적 할당하기도 한다.
    * 메모리나 하드웨어도 접근 가능
    
  * 프로세스 제어 블록 (Process Control Block, PCB)
  
    * 프로세스의 중요 정보 저장하는** OS 자료구조**
  
    * 프로세스 전환이 되면 CPU를 반납하는데, 이때 작업 진행상황이 PCB에 저장
  
    * 다시 CPU할당 받으면 PCB를 통해 이전 중단시점부터 다시 작업
  
    * **PCB들은 연결 리스트로 관리됨**
  
      →   삽입/삭제 용이 (프로세스 생성 시 PCB가 생성되고, 완료 시 제거 됨)
  
    * 저장되는 정보
  
      →   프로세스 식별자(Process ID; PID) : 프로세스 식별변호
  
      →   프로세스 상태 : new, ready, running, waiting, terminated 등
  
      →   프로그램 카운터(PC) : 프로세스가 다음에 실행할 명령어 주소
  
      →   CPU 레지스터
  
      →   CPU 스케줄링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
  
      →   메모리 관리 정보 : 페이지 테이블, 세그먼트 테이블 등
  
      →   입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
  
      →   어카운팅 정보 : 사용된 CPU 시간, 시간제한 등
  
* 스레드(Thread)

  * 프로세스 실행 단위

  * 주소공간 할당 방식

    * Stack만 따로 할당받고, 나머지 영역(Code, Data, Heap)은 다른 스레드와 공유

    * PC 레지스터가 독립적으로 할당되는 이유

      →   PC값은 스레드가 명령어의 어디까지 수행하였는지 나타냄

    * Stack만 독립적인 이유

      →   스레드는 프로세스를 독립적으로 실행하기 때문에, 인자, 지역변수, 리턴값 등도 독립적인 공간에 저장

    * 그 외 영역을 공용하는 이유

      →   컨텍스트 스위칭 시, **다음 스레드에서 사용할 자원을 중복 생성하는 것을 막기 위함입니다**

* cf. 문맥 전환/컨텍스트 스위칭(Context switching)

  * **실행중인 프로세스나 스레드가 변경될 때, 그 상태 정보를 저장 & 복원하는 과정**
  * **프로세스**는 스레드와 달리 **서로 독립된 메모리 영역**을 사용하므로, 무거운 작업 진행 시 오버헤드 발생 가능성



### 2. 멀티 프로세스 & 멀티 스레드 & 멀티 코어

* 멀티 프로세스

  * 여러 프로세스가 각각 독립된 메모리 영역으로 있는 경우
  * 장점
    * 한 프로세스가 문제 생겨도 다른 프로세스에 영향 x
  * 단점
    * **많은 메모리 공간 & CPU 시간 차지**
  * 예. 크롬
  
    * 여러 탭을 띄웠을 때 한 탭에서 오류나도 다른 탭 유지
  
* 멀티 스레드

  * 한 프로세스 내 여러 스레드 구성하여, 여러 작업 처리

  * 장점

    * **적은 메모리 공간 차지**
    * 문맥전환이 빠름
  
  * 단점
  
    * 자원 공유하기 때문에 하나의 스레드 종료 시, 전체 스레드 종료될 수 있음
  
    * **다른 스레드가 사용한 영역에서 엉뚱한 값을 RW할 수 있음**
  
      > 동기화하여 해결 : 임계영역(Critical section)
  
  * 예. 인터넷 익스플로어
  
    * 오류가 나면 모든 텝이 오류남
  
* 멀티 코어

  * 병렬처리(Parallelism)

    * CPU 내 코어들이 동시에 각각 하나 프로세스를 작업

  * <=> 싱글 코어

    * 동시성(Concurrency)

      →   하나의 코어에서 여러 프로세스/스레드가 빠르게 번갈이 진행되어 동시에 진행하는 것 처럼 보임
