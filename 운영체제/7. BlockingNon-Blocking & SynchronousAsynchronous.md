# 7. Blocking/Non-blocking & Synchronous/Asynchronous



### 1. Blocking / Non-blocking

* 호출한 함수와 호출된 함수 중 누가 제어권을 가지냐의 차이

* 함수 A에서 함수 B를 호출한 경우

* Blocking

  * B(호출된 함수)는 자신의 일 마칠 때까지 제어권을 가짐

  * Blocking IO

    * 프로세스(스레드)가 커널에게 IO요청하는 함수 호출

    * 커널이 작업 완료하면 작업 결과를 반환받음

    * IO작업 동안 프로세스(스레드)는 자신의 작업 중단

      →   리소스(자원) 낭비 심함

    * if 많은 클라이언트가 접속하는 서버가 Blocking방식

      →   다른 클라이언트가 진행 중인 작업 중지하면 안되므로, 클라이언트 별 스레드 생성

      →   매우 많아진 스레드로 컨텍스트 스위칭 횟수 증가하여 비효율적

* Non-blocking

  * B(호출된 함수)는 자신의 일 아직 마치지 않았어도, A(호출한 함수)에게 제어권 넘김
  * A(호출한 함수)는 B의 작업이 마칠때까지 기다리지 않고 다음 일 수행 가능
  * Non-blocking IO
    * IO작업 진행동안 프로세스 작업 중단 x



### 2. Synchronous / Asynchronous

* 호출된 함수의 작업상태를 호출한 함수가 신경 쓰는지, 호출된 함수 스스로 신경쓰는지의 차이
* Synchronous
  * A는 B가 작업 상태가 어떤지 계속 체크
  * 작업 수행 주체들이 작업 수행시간(시작, 종료)를 맞춤
    * 서로 동시에 시작
    * 동시에 끝남 
    * 하나가 끝난 후 다른 하나가 시작
* Asynchronous
  * B만 B의 수행상태를 신경 씀
  * 호출된 함수는 작업 완료 시, 호출한 함수에게 Callback을 전달
  * 콜백 오기 전까지 호출한 함수는 신경쓰지 않고 다른 일 수행함 
  * 작업 수행 주체들이 작업 수행시간(시작, 종료)를 맞추지 x
    * 서로의 시작/종료시간 관계없이 별도의 시작/종료시간 가짐
    * 하나가 작업 중인데 다른 하나가 작업 시작하고 끝내고 이런식



### 3. 4개 조합

<img src="C:\Users\angly\AppData\Roaming\Typora\typora-user-images\image-20220417153409610.png" alt="image-20220417153409610" style="zoom:80%;" />

* 블럭킹 & 동기
  * 호출한 함수의 작업이 끝날 때까지 보면서 기다리고 값 반환되면 처리
* 블럭킹 & 비동기
  * 호출한 함수의 작업이 끝날 때까지 기다리되, Callback 호출이 오면 처리
* 넌블럭킹 & 동기
  * 호출된 함수 작업 중에 다음 작업 수행하되, 호출된 함수의 작업 상태를 계속 확인
* 넌블럭킹 & 비동기
  * 호출된 함수 작업 중에 다음 작업을 수행하되, Callback 호출이 오기 전까지 신경 안씀

