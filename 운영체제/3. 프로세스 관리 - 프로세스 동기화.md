# 3. 프로세스 동기화



### 1. 동기(Synchronous) / 비동기(Asynchronous)

* 호출된 함수의 작업상태를 호출한 함수가 신경 쓰는지, 호출된 함수 스스로 신경쓰는지의 차이
* 동기
  * **A는 B가 작업 상태가 어떤지 계속 체크합니다. => 앞 요청 끝날 때까지 다음 요청 처리하지 않고 기다림**
  * 보통, 요청과 결과 반환이 같은 위치에서 일어남
* 비동기
  * A와 B는 서로 수행상태를 모름
  * 호출된 함수는 작업 완료 시, 호출한 함수에게 Callback을 전달
  * 콜백 전까지 호출한 함수는 신경쓰지 않고 다른 일 수행함 
  * 즉, 요청과 결과 반환이 동시에 일어나지 않음 => 앞 요청 처리 시작해도, 기다리지 않고 다음 요청 처리 가능



### 2. 임계영역(Critical Section)

* 공유자원을 접근할 때, 문제가 생기지 않도록, 하나의 프로세스만 이용하도록 보장해야하는 영역

* 보장되지 않을 경우 문제

  * 경쟁 상태(Race Condition) 발생
    * 공유자원에 여러 프로세스가 접근 하여 엉뚱한 값을 RW할 수 있는 상태
    * 자료의 일관성 해침

  * 해결을 위한 조건

    * 상호배제 (Mutual Exclusion)

      →   한 시점에 한 프로세스만 임계영역에서 실행 가능

    * **진행 (Process)**

      →   임계영역이 비었는데, 아무도 사용 못하면 안됨 (교착상태 발생)

    * **한정된 대기 (Bounded Waiting)**

      →   한 프로세스가 임계영역에 진입 신청을 하면, 다른 프로세스들이 임계영역에 진입하는 횟수가 제한됨
      
      →   그래서, 무한정 대기하는 것을 방지



### 3. 임계영역 상호배제 방법

* 세마포어 (Semaphore)

  * 임계영역 문제(경쟁상태)를 해결하는 동기화 도구

    ```python
    # P : 임계구역 진입 전 수행 (진입여부를 자원 갯수S를 통해 결정)
    def P(S):		# 최초의 S값은 1
      while S=0:	# S가 0이면, 1이 될때까지 대기(가용 자원 생길 때까지 진입 불가)
        wait
      S -= 1  # 가용 자원 생기면 자원 하나 감소시킴
    
    # --- Critical Section ---
    
    # V : 임계구역 나올 때 수행 (자원 반납 알림, 대기 중인 프로세스 깨우는 신호)
    def V(S):
      S += 1  # 빠져나오니까 자원 반납
    ```

  * 과정

    1. 먼저 도착한 프로세스 A가 P(S)를 실행하여 S를 0으로 만들고 임계영역 진입
    2. 그 후 도착한 B는 S == 0이라서 while문에서 대기
    3. A가 임계영역 수행 마치고, 빠져나오면 V(S)에 의해 S = 1됨
    4. B는 while 문 빠져나와 임계영역 진입

  * 종류

    →   **카운팅** 세마포어 (Counting Semaphore)

    >* 한정된 갯수를 가진 자원에 대한 접근제어
    >* 세마포어를 자원 갯수로 초기화
    >* 자원 사용하면 세마포어 감소, 반납하면 세마포어 증가

    →   이진 세마포어(Binary Semaphore)

    >* 0과 1값만 가져 임계영역에 들어가는 프로세스가 1개 이도록 하는 세마포어
    >

  * 단점

    * **바쁜 대기 (Busy Wating)**

      →   프로세스가 임계영역 진입이 가능할 때까지 접근 조건을 계속 확인 => CPU자원 소모

    * 해결

      →   진입 실패한 프로세스는 대기상태로 Block 시킨 후, 자리가 날 때 다시 깨움

      →   바쁜 대기로 인해 CPU자원 낭비되는 것을 방지할 수 있음

  * **사용하는 경우**
    
    * **상호배제나, 작업순서 동기화**가 필요한 경우
    * **여러 프로세스가 임계영역 진입**이 가능한 경우
    * **멀티코어** 환경
    * **문맥교환보다, 임계영역 작업이 더 효율**이 좋은 경우

* 뮤텍스(Mutex)

  * **상호배제를 통해 잠금을 해서, 공유자원을 보호하기 위해 사용**

  * 진입이 불가능한 경우, 해당 프로세스는 대기상태로 됨 (바쁜 대기 없음)

  * 이진 세마포어와의 차이 https://blog.naver.com/myca11/222626631093

    * 이진 세마포어

      →   **현재 스레드보다 우선순위 높은 스레드가 세마포어를 가질 수 있음**

      →   다른 스레드/프로세스가 잠금 해제가 가능해서, **뮤텍스보다 빠름**

      →   상호배제도 가능하고, 작업순서 동기화도 가능

    * 뮤텍스

      →   뮤텍스를 획득한 스레드만 뮤텍스 해제 가능

      →   뮤텍스 획득한 스레드만 잠금해제 가능하므로, 이진 세마포어보다 느림

      →   상호배제만 가능

  * 단점
  
    * **다중처리환경에서 효율이 떨어져 사용 불가**

  * 사용하는 경우

    * **상호배제만 필요한 경우**
    * 싱글코어에서 임계영역 작업보다, 문맥교환이 더 효율 좋은 경우
  
  * 알고리즘
  
    * 데커(Dekker) 알고리즘

      →   flag, turn 변수를 통해 임계영역에 진입할 프로세스 결정

      ```python
      # flag : 프로세스 중 누가 임계영역 진입할 지 나타냄
      # turn : 현재 임계영역의 프로세스 차례
      
      while True:
        flag[i] = True    # 프로세스 i가 임계구역 진입 시도
        while flag[j]:    # 프로세스 j가 임계구역에 있는지 확인
          if turn == j:   # j가 임계구역 사용 중이면
            flag[i] = False  # i의 진입 취소
            while turn == j:  # j의 턴이 끝날 때까지 대기
              wait
            flag[i] = True  # 다시 i 진입 시도
      
      # --- Critical Section ---
      
      turn = j          # i의 임계구역 사용 끝나면 턴을 넘김
      flag[i] = False   # 임계구역 사용완료됨을 알림
      ```
  
    * 피터슨(Peterson) 알고리즘
  
      →   데커와 유사하지만,  상대 프로세스에게 진입기회 양보하는 차이

      ```python
      while True:
        flag[i] = True    # 프로세스 i가 임계구역 진입 시도
        turn = j          # j에게 진입 기회 양보
        while flag[j] and turn == j:    # 프로세스 j가 진입 시도하면 대기
          wait
      
      # --- Critical Section ---
      
      flag[i] = False   # 임계구역 사용완료됨을 알림
      ```
  
    * 제과점(Bakery) 알고리즘
  
      →   여러 프로세스 처리 가능

      →   가장 작은 번호 가진 프로세스가 임계구역에 진입

      ```python
      # isReady : 각 프로세스 준비 유무
      # number : 각 프로세스가 받은 번호표
      
      while True:
        isReady[i] = True            # 프로세스 i가 번호표 받은 준비
        number[i] = max(number) + 1  # 현재 프로세스 중 가장 큰 번호 받음
        isReady[i] = False           # 번호표 수령 완료
      
        for j in range(n):     # 모든 프로세스들 번호표 비교 시작
          while isReady[j]:    # 번호표 수령 끝낸 프로세스가 있을 때까지 대기
            wait
      
          # j가 번호표 있으면서, i보다 작은 번호표라면 i 대기
          while number[j] and number[j] < number[i] and j < i:
            wait
      
      # --- Critical Section ---
      
      number[i] = 0   # 임계구역 사용완료됨을 알림
      ```
  
* 모니터(Monitor)

  * 한 프로세스 내의 스레드 간 동기화에 사용되며, 임계영역에 한 스레드만 진입하게 함

  * 세마포어와의 차이

    * 세마포어

      →   **여러 스레드를 진입하게 할 수 있음**

      →   초기 변수값을 설정해줘야 하지만, 모니터는 synchronized 키워드를 붙이기만 하면 되서 더 편리

  * 뮤텍스와의 차이

    * 뮤텍스

      →   다른 프로세스 간 상호배제에도 이용될 수 있음

      →   운영체제에 의해 제공되므로 무겁고 느림

    * 모니터

      →   한 프로세스 내 스레드들에서만 사용됨

      →   프레임워크, 라이브러리에서 제공하므로 세마포어에서 wait, flag 설정 없이, 함수 앞에 synchronized를 붙이면 상호배제 됨 => 빠름



### 5. 교착상태(DeadLock) - 동기화 문제 1

* 프로세스들이 상대 작업이 끝나기를 무한정 기다리며, 자원을 얻지 못해 다음 처리를 못하는 상태

* ex. 

  ​	<img src="https://user-images.githubusercontent.com/70613905/164133181-e8aa8d36-0215-4417-acd2-bcbb6edc40cf.png" style="width:50%;height:50%;" />

  * 프로세스1이 자원1 얻음 & 프로세스2가 자원2 얻음
  * 프로세스1은 자원2 기다림 & 프로세스2는 자원1 기다림
  * 두 프로세스는 무한정 대기상태에 빠짐 = 데드락

* 발생 조건 

  * 4가지를 모두 만족해야 발생
  * 상호배제 (Mutual Exclusion)
    * 자원은 한번에 한 프로세스만 사용 가능
  * 점유 대기 (Hold And Wait)
    * 자원을 가진 상태에서 다른 프로세스의 자원을 요구하며 대기
  * 비선점 (Non Preemption)
    * 다른 프로세스의 자원 선점 불가
  * 순환 대기 (Circular Wait)
    * 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가진 상태

* 식사하는 철학자 문제

  * 교착상태 대표적인 예
  * 원형 테이블에 철학자들이 앉아있고, 그들 양쪽에는 젓가락 한 짝식 있음
  * 밥 먹는 과정
    1. 왼쪽 젓가락부터 집는다. 이미 다른 철학자가 왼쪽 젓가락 사용 중이면, 생각하며 기다림
    2. 왼쪽 들었으면 오른쪽 젓가락 든다. 마찬가지로 오른쪽 젓가락 누가 사용중이면 대기
    3. 두 젓가락을 모두 들었으면 식사
    4. 식사 마치면 오른쪽 젓가락 내려 놓고, 왼쪽 젓가락 내려 놓음

  * 동시에 왼쪽 젓가락을 들었을 경우
    * 상호배제 : 젓가락은 한 명만 사용 가능
    * 점유대기 : 왼쪽 젓가락 든 상태에서 오른쪽 젓가락 할당 대기
    * 비선점 : 남의 젓가락 뺏기 불가능
    * 순환대기 : 각 철학자가 옆의 철학자가 가진 오른쪽 젓가락 필요 & 대기
    * 철학자들은 대기만 하다가 기아현상으로 굶어 죽음

* 해결 방법

  * 예방(Prevention)

    * 4가지 조건 중 하나를 해결

      →   상호배제 부정 : 여러 프로세스가 공유자원 동시 사용

      →   점유대기 부정 : 프로세스 실행 전 모든 자원 할당되어 대기하지 않음

      →   비선점 부정 : 다른 프로세스가 가진 자원 선점 가능

      →   순환대기 부정 : 자원에 고유번호 붙이고, 현재 점유한 자원보다 앞이나 뒤 한 쪽 방향으로만 자원 요구 (선형적)

  * 회피 (Avoidance)

    * 발생조건을 없애기 보다, 발생하지 않도록 

    *  **은행원 알고리즘**

      →   프로세스가 자원 요구 시, 자원 할당 후에 안정상태인지 사전 검사하여  => 안정 상태면 할당, 아니면 다른 프로세스가 자원 반납할 때까지 대기

  * 탐지 (Detection)

    * 교착상태 프로세스와 자원을 탐지하는 알고리즘을 주기적으로 호출
    * **탐지되면 교착상태 회복을 수행**
    
  * 회복 (Recovery)
  
    * 교착상태 발생하고 이를 해결
  
      →   교착상태 프로세스 모두 중지 or 교착상태 제거될 때까지 하나씩 중지
  
      →   교착상태 프로세스 일시 중지하고, 그 프로세스의 자원을 다른 프로세스에게 줌 
  
  * 무시 (Ignore)
  
    * 교착상태 해결할 때에도 문맥교환으로 인한 오버헤드가 발생
    * 따라서 교착상태 성능저하 < 문맥교환 오버헤드 일 경우, 그냥 무시
