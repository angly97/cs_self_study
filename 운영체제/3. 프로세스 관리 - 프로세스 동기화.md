# 3. 프로세스 동기화



### 1. Synchronous / Asynchronous

* 호출된 함수의 작업상태를 호출한 함수가 신경 쓰는지, 호출된 함수 스스로 신경쓰는지의 차이
* Synchronous
  * A는 B가 작업 상태가 어떤지 계속 체크
  * 보통, 요청과 결과 반환이 동시에 일어나서 => 앞 요청 끝날 때까지 다음 요청 처리 불가능
* Asynchronous
  * A와 B는 서로 수행상태를 모름
  * 호출된 함수는 작업 완료 시, 호출한 함수에게 Callback을 전달
  * 콜백 전까지 호출한 함수는 신경쓰지 않고 다른 일 수행함 
  * 요청과 결과 반환이 동시에 일어나지 않음 => 앞 요청 처리 시작해도, 기다리지 않고 다음 요청 처리 가능



### 2. 임계영역(Critical Section)

* 멀티 스레딩 문제처럼, 동일 자원에 동시 접근하는 작업을 실행하는 코드 영역

* 문제

  * 경쟁 상태(Race Condition) 발생
    * 공유자원에 여러 프로세스가 접근 하면, 결과값에 영향을 줌
    * 자료의 일관성 해침

  * 해결을 위한 조건

    * 상호배제 (Mutual Exclusion)

      →   한 시점에 한 프로세스만 Critical Section에서 실행 가능

    * 진행 (Process)

      →   Critical Section 비었는데, 아무도 사용 못하면 안됨(교착상태/데드락 발생)

    * 한정된 대기 (Bounded Waiting)

      →   한 프로세스가 Critical Section에 진입 신청을 할 때 부터 ~ 받아들여질 때까지, 다른 프로세스들이 Critical Section에 진입하는 횟수는 제한되어 있음



### 3. 임계영역 상호배제 방법

* 세마포어 (Semaphore)

  * 소프트웨어에서 Critical Section 문제를 해결하는 동기화 도구

    ```python
    # P : 임계구역 진입 전 수행 (진입여부를 자원 갯수S를 통해 결정)
    def P(S):		# 최초의 S값은 1
      while S=0:	# S가 0이면, 1이 될때까지 대기(가용 자원 생길 때까지 진입 불가)
        wait
      S -= 1  # 가용 자원 생기면 자원 하나 감소시킴
    
    # --- Critical Section ---
    
    # V : 임계구역 나올 때 수행 (자원 반납 알림, 대기 중인 프로세스 깨우는 신호)
    def V(S):
      S += 1  # 빠져나오니까 자원 반납
    ```

  * 과정

    1. 먼저 도착한 프로세스 A가 P(S)를 실행하여 S를 0으로 만들고 임계영역 진입
    2. 그 후 도착한 B는 S == 0이라서 while문에서 대기
    3. A가 임계영역 수행 마치고, 빠져나오면 V(S)에 의해 S = 1됨
    4. B는 while 문 빠져나와 임계영역 진입

  * 종류

    →   카운팅 세마포어 (Counting Semaphore)

    >* 한정된 갯수를 가진 자원에 대한 접근 제어용
    >* 세마포어를 자원 갯수로 초기화
    >* 자원 사용하면 세마포어 감소, 반납하면 세마포어 증가

    →   이진 세마포어/뮤텍스(Binary Semaphore/Mutex Lock)

    >* Critical Section에 진입하는 프로세스는 공유락Lock을 획득 & 빠져나올 때는, Lock 방출하여 동시접근 방지
    >
    >* 0과 1값만 사용 가능 = Critical Section에 들어가는 프로세스 1개
    >
    >* 단점
    >
    >  →   다중 처리 환경에서 시간적 효율 떨어져 적용 불가
    >

* 뮤텍스(Mutex)

  * 알고리즘

    * 데커(Dekker) 알고리즘

      →   flag, turn 변수를 통해 Critical Section 진입할 프로세스 결정

      ```python
      # flag : 프로세스 중 누가 임계영역 진입할 지 나타냄
      # turn : 현재 임계영역의 프로세스 차례
      
      while True:
        flag[i] = True    # 프로세스 i가 임계구역 진입 시도
        while flag[j]:    # 프로세스 j가 임계구역에 있는지 확인
          if turn == j:   # j가 임계구역 사용 중이면
            flag[i] = False  # i의 진입 취소
            while turn == j:  # j의 턴이 끝날 때까지 대기
              wait
            flag[i] = True  # 다시 i 진입 시도
      
      # --- Critical Section ---
      
      turn = j          # i의 임계구역 사용 끝나면 턴을 넘김
      flag[i] = False   # 임계구역 사용완료됨을 알림
      ```

    * 피터슨(Peterson) 알고리즘

      →   데커와 유사하지만,  상대 프로세스에게 진입기회 양보하는 차이

      ```python
      while True:
        flag[i] = True    # 프로세스 i가 임계구역 진입 시도
        turn = j          # j에게 진입 기회 양보
        while flag[j] and turn == j:    # 프로세스 j가 진입 시도하면 대기
          wait
      
      # --- Critical Section ---
      
      flag[i] = False   # 임계구역 사용완료됨을 알림
      ```

    * 제과점(Bakery) 알고리즘

      →   여러 프로세스 처리 가능

      →   가장 작은 번호 가진 프로세스가 임계구역에 진입

      ```python
      # isReady : 각 프로세스 준비 유무
      # number : 각 프로세스가 받은 번호표
      
      while True:
        isReady[i] = True            # 프로세스 i가 번호표 받은 준비
        number[i] = max(number) + 1  # 현재 프로세스 중 가장 큰 번호 받음
        isReady[i] = False           # 번호표 수령 완료
      
        for j in range(n):     # 모든 프로세스들 번호표 비교 시작
          while isReady[j]:    # 번호표 수령 끝낸 프로세스가 있을 때까지 대기
            wait
      
          # j가 번호표 있으면서, i보다 작은 번호표라면 i 대기
          while number[j] and number[j] < number[i] and j < i:
            wait
      
      # --- Critical Section ---
      
      number[i] = 0   # 임계구역 사용완료됨을 알림
      ```

  * 초기 세마포어 단점

    * 바쁜 대기 (Busy Wating)

      →   프로세스가 임계영역 진입이 가능할 때까지 접근 조건을 반복 확인

      →   세마포어를 통한 상호배제에서 whlie문 대기

    * 해결

      →   진입 실패한 프로세스는 Block 시킨 후(대기 상태), 자리가 날 때 다시 깨움

      →   바쁜 대기로 인해 CPU자원 낭비되는 것 방지

* 모니터(Monitor)

  * 한 프로세스 내의 다른 스레드 간 동기화에 사용
  * 프레임워크나 라이브러리 자체에서 제공
  * 세마포어에서 wait, flag 설정 없이, 함수 앞에 synchronized를 붙이면 상호배제 됨



### 5. 교착상태(DeadLock) - 동기화 문제 1

* 프로세스들이 서로 상대의 작업이 끝나기를 무한정 기다리며, 자원을 얻지 못해 다음 처리를 못하는 상태

* ex. 

  ​	<img src="https://user-images.githubusercontent.com/70613905/164133181-e8aa8d36-0215-4417-acd2-bcbb6edc40cf.png" style="width:50%;height:50%;" />

  * 프로세스1이 자원1 얻음 & 프로세스2가 자원2 얻음
  * 프로세스1은 자원2 기다림 & 프로세스2는 자원1 기다림
  * 두 프로세스는 무한정 대기상태에 빠짐 = 데드락

* 발생 조건 

  * 4가지를 모두 만족해야 발생
  * 상호배제 (Mutual Exclusion)
    * 자원은 한번에 한 프로세스만 사용 가능
  * 점유 대기 (Hold And Wait)
    * 자원을 가진 상태에서 다른 프로세스의 자원을 요구하며 대기
  * 비선점 (Non Preemption)
    * 다른 프로세스의 자원 선점 불가
  * 순환 대기 (Circular Wait)
    * 각 프로세스가 순환적으로 다음 프로세스가 가진 자원을 요구하는 상태

* 식사하는 철학자 문제

  * 교착상태 대표적인 예
  * 원형 테이블에 철학자들이 앉아있고, 그들 양쪽에는 젓가락 한 짝식 있음
  * 밥 먹는 과정
    1. 왼쪽 젓가락부터 집는다. 이미 다른 철학자가 왼쪽 젓가락 사용 중이면, 생각하며 기다림
    2. 왼쪽 들었으면 오른쪽 젓가락 든다. 마찬가지로 오른쪽 젓가락 누가 사용중이면 대기
    3. 두 젓가락을 모두 들었으면 식사
    4. 식사 마치면 오른쪽 젓가락 내려 놓고, 왼쪽 젓가락 내려 놓음

  * 동시에 왼쪽 젓가락을 들었을 경우
    * 상호배제 : 젓가락은 한 명만 사용 가능
    * 점유대기 : 왼쪽 젓가락 든 상태에서 오른쪽 젓가락 할당 대기
    * 비선점 : 남의 젓가락 뺏기 불가능
    * 순환대기 : 각 철학자가 옆의 철학자가 가진 오른쪽 젓가락 필요 & 대기
    * 철학자들은 대기만 하다가 기아현상으로 굶어 죽음

* 해결 방법

  * 예방(Prevention)

    * 4가지 조건 중 하나를 해결

      →   상호배제 부정 : 여러 프로세스가 공유자원 동시 사용

      →   점유대기 부정 : 프로세스 실행 전 모든 자원 할당

      →   비선점 부정 : 다른 프로세스가 가진 자원 선점 가능

      →   순환대기 부정 : 자원에 고유번호 붙이고, 현재 점유한 자원보다 앞이나 뒤 한 쪽 방향으로만 자원 요구 (선형적)

  * 회피 (Avoidance)

    * 발생조건을 없애기 보다, 발생하지 않도록 

    *  은행원 알고리즘

      →   은행에서 모든 고객 요구 충족되게 현금할당하는 것에서 유래

      →   프로세스가 자원 요구 시, 자원 할당 후에 안정상태인지 사전 검사하여 교착상태 회피 => 안정 상태면 할당, 아니면 다른 프로세스가 자원 반납할 때까지 대기

  * 탐지 (Detection)

    * 교착상태 프로세스와 자원을 탐지하는 알고리즘을 주기적으로 호출
    
  * 회복 (Recovery)
  
    * 교착상태 발생하고 이를 해결
  
      →   교착상태 프로세스 모두 중지 or 교착상태 제거될 때까지 하나씩 중지
  
      →   교착상태 프로세스 일시 중지하고, 그 프로세스의 자원을 다른 프로세스에게 줌 
  
  * 무시 (Ignore)
  
    * 교착상태 해결할 때에도 문맥교환으로 인한 오버헤드가 발생
    * 따라서 교착상태 성능저하 < 문맥교환 오버헤드 일 경우, 그냥 무시
