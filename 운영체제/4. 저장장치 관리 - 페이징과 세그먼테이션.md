# 4. 페이징과 세그먼테이션



### 1. 메모리 관리 배경

* 각 프로세스는 독립된 메모리 공간을 가짐 & OS나 다른 프로세스 메모리 접근 X

* OS만이 OS메모리 & 사용자 메모리 영역 접근 제약 X

* Swapping

  * Swap은 큰 디스크 전송시간이 걸리므로, 메모리 공간이 부족할 경우에 수행
  * Swap-Out
    * CPU할당 시간 끝난 프로세스 메모리를, 보조기억장치(하드디스크)로 내보냄
  * Swap-In
    * 다른 프로세스 메모리를 주기억장치(RAM)에 올림

* 연속 메모리 관리

  * 프로그램 전체가 메모리에 연속적으로 할당

  * 종류

    * 고정 분할 기법

      →   주기억장치가 고정된 파티션으로 분할됨

      →   내부 단편화 발생

    * 동적 분할 기법

      →   필요한 크기만큼의 파티션들이 생성되어 적재됨

      →   외부 단편화 발생

* 단편화(Fragmentation)

  * 메모리 공간이 낭비되는 현상

  * 종류

    * 외부 단편화

      →   용량 문제로 한 분할 영역 전체가 낭비됨

    * 내부 단편화

      →   분할 영역 내에서 발생하는 공간 낭비

  * 해결 

    * 압축

      →   외부 단편화 해결을 위해, 프로세스가 사용하는 메모리 공간을 한 쪽에 몰아넣음

      →  메모리 이동 작업은 비싸서 효율이 안 좋음

    * 페이징 & 세그먼테이션

      →   한 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약 없앤 메모리 관리

      →   압축의 문제점 해결



### 2. 페이징(Paging)

* 프로그램을 같은 크기의 블록(페이지&프레임)들로 분할
  * 페이지
    * 보조기억장치 분할 영역으로 논리 메모리 블록
  * 페이지 프레임
    * 주기억장치 분할 영역으로  물리 메모리 블록
* 논리 메모리가 연속&순서 상관없이 물리 메모리에 매핑됨
* 장점
  * 단순해서 효율적

* 단점
  * 프로그램마다 크기 다름 But, 페이지 크기가 일정 => 내부 단편화 심해짐



### 3. 세그먼테이션(Segmentation)

* 프로그램을 다른 크기의 논리적 단위(세그먼트)로 분할
* 2개의 주소를 이용하여 물리적 메모리 주소에 매핑됨
  * 세그먼트 번호 + 변위
* 단점
  * 세그먼트들이 메모리 적재&제거 반복되면, 자유공간들이 서로다른 크기 조각들로 나뉘어져 외부 단편화 발생
  * 다른 크기의 세그먼트 관리 오버헤드 증가