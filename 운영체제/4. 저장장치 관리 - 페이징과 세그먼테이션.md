# 4. 페이징과 세그먼테이션



### 1. 메모리 관리 배경

* ~배경 스토리~
  - 각 프로세스는 독립된 메모리를 가지며, 다른 프로세스 메모리에 접근 불가
  - 하지만 OS는 User영역에 접근 가능
  - 따라서 OS가 메모리를 관리하게 됨

* 필요성
  - 메모리는 한정된 자원이기 때문에, 여러 프로세스 메모리를 효율적으로 관리해야야 함
    - 프로세스는 물리 메모리 주소를 직접 참조하지 않고, 프로세스의 주소 공간(가상 주소 공간)을 참조
    - 프로세스는 자신의 주소 공간 내에서 작업을 수행하고, 이 가상 주소 공간은 OS에 의해 실제 메모리 주소로 매핑됨
    - 따라서 좀 더 빠르게 물리 메모리 주소를 참조할 수 있는 관리 방법도 추가적으로 필요함.
* Swapping

  * 프로세스를 주기억장치에 적재하고, 내리는 작업
  * Swap-Out
    * CPU를 반납한 프로세스의 메모리를, 보조기억장치(하드디스크)로 내보냄
  * Swap-In
    * 프로세스의 메모리를 주기억장치(RAM)에 올림




### 3. 메모리 할당 종류

- **연속 메모리 할당**

  - **프로그램 전체가 메모리에 연속적으로 할당**

  - 종류

    - **고정 분할 기법 (정적 할당)**

      - 물리 메모리를 **영구적인 분할로 미리 나누어 두고**, 각 분할에 하나의 프로세스를 적재하는 방식

      - 각 분할의 크기는 모두 동일할 수도 있고, 서로 다를 수도 있음

      - 장점

        - 구현이 쉽다

      - 단점

        - 동시에 메모리에 올릴 수 있는 프로그램 수가 고정

          되어 있음

          - 주기억장치의 **분할 영역의 수만큼** 한정됨
          - 따라서 **융통성이 떨어짐**

        - **외부 단편화와 내부 단편화** 많이 발생

        ⇒ 따라서 현대의 OS에선 잘 사용되지 않음

    - **가변 분할 기법 (동적 할당)**

      - 메모리에 적재되는 **프로그램의 크기에 따라 분할의 크기가 동적으로 변하는 방식**
      - **장점**
        - 내부 단편화 없음
          - 딱 프로그램 크기만큼 메모리가 분할되기 때문
      - **단점**
        - 약간 복잡
        - **외부 단편화는 여전히 발생**
          - 프로그램들의 메모리 적재와 제거가 반복되면 메모리가 쪼개져 외부 단편화 발생
        - **동적 메모리 할당 문제 발생**
          - 빈공간 A와 B중 어떤 위치에 새로운 프로그램을 적재할 지 결정해야 하는 문제
          - 해결
            - 메모리 배치 전략
              - 종류
                - 최초 적합 (First-Fit)
                  - 프로그램보다 큰 가용공간 중 가장 먼저 찾는 곳에 적재
                  - 장점 : 가장 빠름
                  - 단점 : 메모리 효율이 좋진 않음
                - 최적 적합 (Best-Fit)
                  - 프로그램보다 큰 가용공간 중 가장 작은 곳에 적재
                  - 장점 : 메모리 효율 좋음
                  - 단점 : 모든 가용공간을 탐색해야하므로 시간적 오버헤드 발생
                - 최악 적합 (Worst-Fit)
                  - 프로그램보다 큰 가용공간 중 가장 큰 곳에 적재

- 불연속 메모리 할당

  - 하나의 프로세스가 메모리 여러 영역에 분산되어 적재됨

  * 종류

    * 페이징 기법

      * 프로그램은 페이지로, 주기억장치는 프레임들로 미리 분할됨

        > 여기서, 페이지는 가상메모리를 일정한 크기로 나눈 블록이고
        >
        > 프레임은 물리메모리를 일정한 크기로 나눈 블록이다.

      * 프레임보다 페이지가 더 작을 경우, 내부 단편화 발생

    * 세그멘테이션 기법

      * 필요한 크기만큼의 세그먼테이션들이 동적으로 생성되어 적재됨

      * **2개의 주소를 이용하여 물리주소로 매핑됨**

        →   세그먼트 번호 + 변위

      * 단점

        →   **세그먼트들이 메모리 적재&제거 반복되면, 메모리가 계속 쪼개져** 외부 단편화 발생

        →   다양한 크기의 세그먼트를 동적할당하며 오버헤드 증가

        →   **프로그램에서 실행되는 기능의 변화가 적은 경우? **

        > 세그먼트들이 메모리 적재&제거 반복이 적은 경우





### 3. 단편화(Fragmentation)

* **메모리 공간이 낭비되는 현상**

* 종류

  * 외부 단편화

    →   용량이 맞지 않아 한 분할 영역 전체가 낭비됨

  * 내부 단편화

    →   분할 영역 내에서 발생하는 공간 낭비

* 해결 

  * 메모리 압축

    →   외부 단편화를 해결하기 위해, 프로세스가 차지한 메모리 공간을 한 쪽에 몰아넣음

    →   But 메모리 이동 작업의 효율이 안 좋음

  * 가상메모리 기법

    →   **한 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약 없앤 것**

    →   압축의 문제점 해결
