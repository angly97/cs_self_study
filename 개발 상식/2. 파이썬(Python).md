# 1. 파이썬(Python)

>* 컴파일
>
>  소스코드가 기계어 코드로 번역됨
>
>* 런타임
>
>  컴파일 후,  실행되어지는 때
>
>* 빌드
>
>  소스코드를 실행가능한 상태로 만듦
>
>  빌드 안에 컴파일 과정이 있음



### 1. 특징

* 인터프리터 언어

  * 소스코드를 기계어로 변환하지 않고 한 줄씩 해석하여 실행
  * 인터프리터가 직접 한 줄씩 읽고, 기계어로 컴파일 안하므로, 빌드 시간 없음
  * 빌드 시간은 없지만, 런타임(실행시간)이 느림
    * 런타임 시, 한 줄 한 줄 해석하며 실행하기 때문에
  * ex. Ruby 등
  * <=> 컴파일 언어
    * 소스코드를 모두 기계어로 변환 후, 기계어 코드를 실행
    * 빌드과정에 있어 인터프리터 언어에 비해 시간 소요됨
    * 빌드 시간은 있지만, 빌드 후엔 바로 실행 가능하므로, 실행시간은 빠름

* 객체지향 언어

  * 클래스와 인스턴스를 중심으로 돌아가기 때문에

    * 객체지향 프로그래밍 패러다임 기능

      →   캡슐화, 추상화, 상속, 다형성

      →   정보은닉 : 외부에 데이터 감추는 것

      >  _(언더스코어)변수 => class 내에서만 접근가능한 private변수
      >
      > * 언더스코어 기능
      >   1. 파이썬 프롬프트나 인터프리터가 마지막으로 실행한 구문 값을 리턴
      >   2. 값을 무시
      >   3. 특별한 의미 부여
      >   4. 더블 언더스코어
      >   5. 국제화/지역화
      >   6. 숫자 리터럴의 자릿수 구분자로 사용

* 동적 타입 언어(Dynamically Typed Languages)

  * 컴파일이 아니라 런타임 시 변수 타입 결정

  * 장점

    * 런타임까지 타입 결정을 미룰 수 있기에, 유연성 높음
    * 코드 작성 시 편리

  * 단점

    * 실행 도중, 변수에 예상치 못한 타입이 들어와 타입 에러 가능성

  * <=> 정적타입 언어(Statically Typed Language)

    * 컴파일 시 변수 타입이 결정됨

    * 따라서, 프로그래머가 변수 타입 명시해 주어야 함

    * 장점

      →   타입 에러로 인한 문제점을 초기에 발견

      →   컴파일 시, 미리 타입 결정하기 때문에 실행속도 빠름

    * 단점

      →   매번 코드 작성 시 알맞은 자료형 결정해야 함

* 단점/약점/문제점

  * 실행**속도** 느림
    * 인터프리터 언어라서
  * **모바일 컴퓨팅**에 취약
    * 데이터베이스 엑세스 계층이 저개발이기 때문에
    * 다른 언어에 비해 **메모리를 더 소비**하고, 처리 속도 느림
  * **브라우저**에 안에서 Javascript 처럼 객체를 다룰 수 없음
    * 서버 언어로는 좋지만, 클라이언트 개발에는 안 좋음
  * 동적타이핑 언어이기에 **덕 타이핑(Duck-Typing)** 사용       // optional
    * 객체의 변수와 메소드가 그 객체의 자료형을 결정
    * 여기서 런타임 에러 발생할 수 있음



### 2. Array VS List VS Tuple VS Set

* Array
  * **같은 자료형**을 순차적으로 모음
* List
  * 서로 다른 자료형이 가능하고, 순서가 있는 자료구조
  * 음수 인덱스로 접근 시, 오른쪽 데이터 기준으로 -1이 첫번째 데이터이며, 오른쪽부터 검사
  * list.append()
    * 리스트 제일 뒤에 들어온 값을 추가
  * list.extend()
    * 리스트 뒤에 iterable(반복 가능한) 변수의 원소들을 추가
* Tuple
  * 서로 다른 자료형이 가능하고, 순서가 있지만, **데이터 변경 불가능**
  * 인덱스 접근 
* Set
  * 서로 다른 자료형 가능하지만, **원소들은 변경 불가능한 자료형**, **순서 없음**
  * **중복 제거**
  * **list에서 중복 제거하기**



### 3. 연산자

* 삼항연산자(Ternary Operator)

  * Javascript와 C++과 달리 파이썬은 삼항 연산자가 없음

  * 비슷한 다른 역할하는 것 존재

  * [참일 때 코드] if 조건 else [거짓일때 코드]

* //

  * 나눗셈 후, 내림한 정수

* % 

  * 나머지

* **

  * 제곱



### 4. 변수명/함수명 식별자

* 길이 제한이 없다고 하지만 PEP-8 가이드라인은 한 줄 최대 79자, PEP-20은 가독성이 중요하다고 함
* 따라서 너무 긴 식별자는 PEP-8, PEP-20을 위반
* PEP(Python Enhancement Proposal; 파이썬 개선 제안)/파이썬 스타일 가이드
  * 파이썬 코드 가독성을 향상시키고, 작성법 일관성을 위한 가이드



### 5. pass VS continue

* pass
  * 파이썬은 함수 작성 시, 반드시 안에 내용을 작성해야 문법적으로 올바르기 때문에 pass를 사용하여 문법 오류 방지
* continue
  * 반복문에서 해당 차례에 더 이상 진행하지 않고, 다음 차례로 넘어가기 위한 키워드



### 6. 현재 작업중인 디렉토리 확인

* os 모듈 안의 getcwd 메소드 사용

  ```python
  import os
  print(os.getcwd())
  
  # C:\Users\...
  ```



### 7. 내장 함수(빌트인 함수)

* eval() : 문자열 연산 수식을 연산
* map(함수, 이터러블 변수)
  * 2개의 인수(함수, 이터러블 변수)를 받음
  * 이터러블 변수의 원소들에 순서대로 함수를 적용한 값을 리턴

* filter() : iterable 변수에서 조건 적용
* len()
* min/max/abs/sum ...



### 8. .pyc VS .py

* pyc
  * py의 컴파일된 버전으로, py를 읽어 실행시킬때 자동 생성되는 파일
    * 파이썬은 성능 향상시키기 위해 자동으로 pyc파일 생성
  * 플랫폼에 독립적인 바이트 코드
    * PVM(파이썬 가상 머신)이 이해할 수 있는 바이트 코드
    * 따라서 .pyc 형식 지원하는 모든 플랫폼에서 실행 가능
  * 과정
    1. .py를 PVM이 이해할 수 있는 바이트 코드로 컴파일
    2. 컴파일된 바이트코드를 PVM이 단계별로 실행



### 9. Try

* Try ...raise... except ... else ... finally

  ```python
  try:
      에러 발생할 수 있는 코드 작성
      raise KeyboardInterrupt		# 발생가능한 오류 종류를 명시
  except:
      에러 처리
  else:
      에러 발생 안할 경우
  finally:
      에러 나든 말든 실행
  ```



### 10. 파일

* open('파일명', '모드')
  * 모드로 파일 열기
  * 모드
    * r : 읽기 전용
    * w : 쓰기 전용
    * rw : 읽기 쓰기 전용
    * a : 덧붙이기
    * t모드 : 텍스트 파일로 + 모드 (tr :텍스트파일로 읽기 전용)
    * b모드 : 이진 파일로 + 모드



### 11. 언더스코어 기능

* 파이썬 프롬프트나 인터프리터가 마지막으로 실행한 구문 값을 리턴

* 값을 무시
  * 필요하지 않은 값을 _ 에 할당

* 특별한 의미 부여
  * private 클래스/함수/변수를 선언 시 _이름 으로 선언
  * 이러면, 해당 모듈이 import될 때, _로 시작하는 것은 임포트에서 제외됨

* 숫자 리터럴의 자릿수 구분자로 사용
  * 우리가 숫자 작성 시, 1000(천), 1,000,000(백만) 처럼 3칸마다 , 찍는 것처럼 숫자 값을 더 쉽게 보도록 



### 12. switch ... case 문

* 파이썬에서 지원하지 않음

* 딕셔너리 매핑으로 구현 가능

  ```python
  def switch(x):
      return {
          'one':1,
          'two':2,
          'three':3
      }.get(x, 5)		# 딕셔너리에 x가 없을 경우, 5 반환
  ```



### 13. 제너레이터

* iterator를 생성하는 함수
  * yield 키워드로 원소 생성
* 무한한 순서가 있는 객체 생성 가능
* 순서의 다음 값은 필요에 따라 계산 가능
* 동작
  1. yield 문이 포함된 generator함수를 실행하면 generator객체  반환됨
  2. next() 메서드를 통해 generator 실행시키며, 객체의 원소를 순차적으로 반환
  3. next() 메서드 호출하면, 함수 내용 실행하다가 yield 문 만나면 처리 중단 
  4. 다시 next 호출하면, 이전 중단점부터 다시 실행하다가 yield문에서 중단
* 장점
  * 메모리 절약 가능
    * list 등 이터러블 객체를 for로 탐색하면, 객체 크기만큼 메모리 소모
    * But!! generator는 yield를 통해 그때그때 필요한 값만 받기에 메모리 절약



### 14. PyPy가 CPython 보다 빠른 이유

* pypy는 일반 인터프리터가 아니라 JIT(Just In Time)컴파일 제공하는 인터프리터
  * JIT 컴파일러
    * 바



### 15. 파이썬의 내부 sort

* timsort 알고리즘으로 구현됨
  * merge + insert가 혼합된 안정정렬



