# 1. 개발 상식



### 1. 좋은 코드

* 가독성이 좋음
* 중복된 부분 최소화
* 함수는 한가지 일만 수행
  * 여러 가지 일을 하면 다른 기능이 자신이 모르는 사이에 실행될 수 있음



### 2. 객체 지향 프로그래밍 (Object Oriendted Programming)

* 현실 세계 사물들을 객체로 하고, 그 객체로부터 개발하려는 애플리케이션의 특징을 뽑아와 프로그래밍

* <=> 절차적/구조적 프로그래밍

  * 반복되는 코드를 함수(프로시저)로 만들어 사용

  * ex. 도서 관리 프로그램

    * 책에 해당하는 자료형과 책 관련 함수를 따로 만들어야 함

      ​	→   많은 데이터 만들 때 구분이 힘듦 

    * 책에 대한 자료형, 책에 대한 함수가 같은 위치에 있을 순 있지만, 논리적으로 함께하지 못함

    * 이를 한번에 묶기 위한 패러다임 == OOP

* OOP 장단점

  * 장점
    * 객체 단위로 코드가 나뉘어서
      1. 코드 재사용 높음
      2. 디버깅이 쉽고, 유지보수에 용이
  * 단점
    * 객체 간 정보 교환이 모두 메시지로 일어나므로, 많은 Overhead 발생(= 처리 오래 걸림)
    * 용량이 커짐
    * 객체의 상태(속성, 행위)에 대한 처리로 인해 시간과 노력이 필요

* OOP 5원칙(SOLID)

  * SRP(Single Responsibility Principle) 단일 책임 원칙

    * 한 클래스는 하나의 책임을 가짐
    * 따라서 클래스를 변경하는 이유는 단 하나의 이유
    * 시스템이 커지면 서로 많은 의존성을 갖는데, 수정 요청이 오면 수정할 대상 1개만 수정하면 됨
    * ex. 유저를 추가할 때, 클래스에 비밀번호 암호화 기능도 있다면, 유저 속성을 추가할 때에도, 비밀번호 암호 방식을 변경하고 싶을 때에도 user 클래스를 변경하게 됨

  * OCP(Open-Closed Principle) 개방-폐쇄 원칙

    * 확장에는 열려있어야 하고, 변경에는 닫혀있어야 함

    * 확장

       →  새로운 기능 추가

    * 변경

       →  기존 코드 수정하지 않음

  * LSP(Liskov Substitution Principle) 리스코프 치환 원칙

    * 상위 객체를 하위 객체로 치환해도 상위 타입을 사용하는 프로그램을 정상 작동

  * ISP(Interface Segregation Principle) 인터페이스 분리 원칙

    * 인터페이스가 잘 분리되어서, 클래스가 꼭 필요한 인터페이스만 구현하도록 함
    * 구현할 객체에게 무의미한 메소드 구현 방지를 위해, 꼭 필요한 메소드만 상속함

  * DIP(Dependency Inversion Principle) 의존 역전 원칙

    * 상위모듈이 하위모듈에 의존해선 안됨
    * 고수준 모듈  →  변경이 없는 추상화된 클래스 or 인터페이스
    * 저수준 모듈  →  변하기 쉬운 구체 클래스
    * 둘 다 추상화에 의존하며, 추상화는 세부 사항에 의존해선 안됨

* 4가지 특징

  * 캡슐화(Encapsulation)

    * 구현 부분을 외부에 드러나지 않도록 (정보 은닉)

    * 변수와 메소드를 하나로 묶음

    * 데이터를 외부에서 직접 접근하지 않고, 함수를 통해서 접근(낮은 결합도=낮은 의존성)

    * 왜 필요? 한 곳의 변화가 다른곳에 미치는 영향 최소화

    * ex. 

      public → 클래스 외부 접근 o

      priviate → 클래스 내부 접근만 o

      protected → 상속받은 클래스에서만 o

  * 상속(Inheritance) = 일반화(Generalization)

    * 자식 클래스가 부모 클래스의 특정과 기능을 물려받음

    * 왜 필요? 캡슐화 & 클래스 재사용 용이하게 함

      →  자식 클래스 자체를 캡슐화하여 다른 외부 클래스 자식클래스들에 뭐가 있는지 정보 알 수 없음

  * 추상화(Abstaction)

    * 인터페이스
    * 클래스의 공통 특성(변수, 메소드)를 묶어 표현
    * 왜 필요? 새로운 하위 종류가 생기면 기존 것 수정 없이 새로 추가로 만들 부분만 생성하면 됨 

  * 다형성(Polymorphism)

    * 어떤 변수, 메소드가 상황에 따라 다른 결과 내는 것
    * 오버로딩 →  메소드 이름 같지만, 파라메터 다른 것 (리턴값만 다른 X)
    * 오버라이딩 → 부모 클래스의 메소드를 자식클래스 용도에 맞게 재정의
    * 왜 필요? 코드 간결 & 유연성



### 3. TDD(Test-Driven Development; 테스트 주도 개발) 

* 개발 코드 작성 전 테스트 코드를 먼저 작성하는 개발 방법론
* 과정
  1. 한 가지 기능 내 한 가지 케이스의 테스트 작성
  2. 기능 구현된 것 없으므로 테스트 실패
  3. 실패한 테스트만 성공하는 최소한의 코드 작성
  4. 코드 리펙토링
     * 가독성을 위한 coding convention 맞추기
     * 예외 처리
     * 메소드가 한가지 일만 하도록 분리
     * 중복 최소화
  5. 다음 기능의 테스트 작성하고 다시 반복

* 왜 해야해?
  * 피드백과 협력이 자주 이루어짐
    * 피드백: 테스트 코드를 통해 테스트 통과인지 불통인지 자주 확인
    * 협력: 테스트 코드 공유할 수 있어서 다른사람들이 코드 의도 빠르게 이해 가능
  * 처음해보는 프로그램 주제
    * 나에대한 불확실성이 적은 경우
  * 고객 요구사항이 바뀔 수 있는 프로젝트
    * 외부적인 불확실성이 높은 경우
  * 개발 중 코드 수정이 많은 경우
  * 유지보수하는 사람과 개발하는 사람이 다를 경우

* 장단점

  * 장점

    * 테스트 작성을 위해선 요구사항 분석 & 이해 필요

      →   따라서 모든 요구사항에 집중하게 함

    * 유닛테스팅 덕에 특정 버그 찾기 쉬움 →  디버깅 시간 단축

    * 새로운 기능 추가 시, 추가 후에도 기존 테스트가 잘 작동하는 지 검사 가능

    * 테스트 문서 대체 가능

  * 단점

    * 코드 생산성 저하

      →  개발코드 & 테스트코드 2개를 짜야해서

      →  중간마다 테스트하며 고쳐나가야 해서



### 4. 함수형 프로그래밍

- 순수함수를 조합함으로써, 공유/변경 가능한 데이터와 부작용을 예방하여 SW만드는 프로세스

  - 순수함수를 조합하여 부수효과 줄이고 모듈화 수준을 높임

  - 순수함수(Pure functions)

    - 반드시 하나 이상의 인자를 받아, 받은 인자만 처리해 반드시 결과물 돌려줌

    - 인자 외 다른 변수 사용 금지 = 숨겨진 입출력 제거

      ```javascript
      var arr = [1,2,3,4,5]
      var condition = function(x) { return x%2==0; }
      
      // 순수함수 x
      var ex = function(array) {
          return array.filter(condition)	// 받은 인자 array아닌 conditiont사용
      };
      ex(arr);
      
      
      // 순수 함수
      var ex = function(array, cond) {
          return array.filter(cond)	// array, cond = 인자
      };
      ex(arr, condition)
      
      ```

- 애플리케이션 상태가 공유되고 객체 메서드와 함께 배치되는 OOP와 대조

- 선언형 프로그래밍 (반응형 프로그래밍)

  * How보다는 What을 설명하는 방식(무엇을 할 건지 표현)
  * 알고리즘을 명시하지 않고 목표만 명시
  * cf. 명령형 프로그래밍
    * 절차지향, 객체지향
    * 알고리즘 명시 (어떻게 할지 표현)

- java에서 함수형 프로그래밍

  - 람다식, stream api, 함수형 인터페이스

    ```java
    List<String> myList = Arrays.asList("a", "b", "c", "d", "e");
    
    // 기존방식 : 데이터 처리 방식이 한 눈에 보임 
    for(int i=0; i<myList.size(); i++){
    	String s = myList.get(i);
        if(s.startsWith("c")){
        	System.out.println(s.toUpperCase());
    	}
    }
    
    // stream API를 이용한 방식 : 한 눈에 내가 무엇을 구현했는지 알 수 있음
    myList.stream()
    	.filter(s -> s.startsWith("c"))
    	.map(String::toUpperCase)
    	.forEach(System.out::println);
    ```



