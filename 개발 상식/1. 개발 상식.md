# 1. 개발 상식



### 1. 좋은 코드

* 가독성이 좋음
* 중복된 부분 최소화
* 함수는 한가지 일만 수행
  * 여러 가지 일을 하면 다른 기능이 자신이 모르는 사이에 실행될 수 있음



### 2. 객체 지향 프로그래밍 (Object Oriendted Programming)

* 현실 세계 사물들을 객체로 하고, 그 객체로부터 개발하려는 애플리케이션의 특징을 뽑아와 프로그래밍

* <=> 절차적/구조적 프로그래밍

  * 반복되는 코드를 함수(프로시저)로 만들어 사용

  * ex. 도서 관리 프로그램

    * 책에 해당하는 자료형과 책 관련 함수를 따로 만들어야 함

      ​	→   많은 데이터 만들 때 구분이 힘듦 

    * 책에 대한 자료형, 책에 대한 함수가 같은 위치에 있을 순 있지만, 논리적으로 함께하지 못함

    * 이를 한번에 묶기 위한 패러다임 == OOP

* OOP 장단점

  * 장점
    * 객체 단위로 코드가 나뉘어서
      1. 코드 재사용 높음
      2. 디버깅이 쉽고, 유지보수에 용이
  * 단점
    * 객체 간 정보 교환이 모두 메시지로 일어나므로, 많은 Overhead 발생(= 처리 오래 걸림)
    * 용량이 커짐
    * 객체의 상태(속성, 행위)에 대한 처리로 인해 시간과 노력이 필요

* OOP 5원칙(SOLID)

  * SRP(Single Responsibility Principle) 단일 책임 원칙

    * 한 클래스는 하나의 책임을 가짐
    * 따라서 클래스를 변경하는 이유는 단 하나의 이유
    * 시스템이 커지면 서로 많은 의존성을 갖는데, 수정 요청이 오면 수정할 대상 1개만 수정하면 됨
    * ex. 유저를 추가할 때, 클래스에 비밀번호 암호화 기능도 있다면, 유저 속성을 추가할 때에도, 비밀번호 암호 방식을 변경하고 싶을 때에도 user 클래스를 변경하게 됨

  * OCP(Open-Closed Principle) 개방-폐쇄 원칙

    * 확장에는 열려있어야 하고, 변경에는 닫혀있어야 함

    * 확장

       →  새로운 기능 추가

    * 변경

       →  기존 코드 수정하지 않음

  * LSP(Liskov Substitution Principle) 리스코프 치환 원칙

    * 상위 객체를 하위 객체로 치환해도 상위 타입을 사용하는 프로그램을 정상 작동

  * ISP(Interface Segregation Principle) 인터페이스 분리 원칙

    * 인터페이스는 그 인터페이스를 사용하는 클라이언트 기준으로 분리해야 함

  * DIP(Dependency Inversion Principle) 의존 역전 원칙

    * 고수준 모듈은 저수준 모듈의 구현에 의존해선 안됨
    * 추상화에 의존하며 구체화에는 의존하지 않는 설계
    * 고수준 모듈  →  변경이 없는 추상화된 클래스 or 인터페이스
    * 저수준 모듈  →  변하기 쉬운 구체 클래스

* 4가지 특징

  * 캡슐화(Encapsulation)

    * 구현 부분을 외부에 드러나지 않도록 (정보 은닉)

    * 변수와 메소드를 하나로 묶음

    * 데이터를 외부에서 직접 접근하지 않고, 함수를 통해서 접근(낮은 결합도=낮은 의존성)

    * 왜 필요? 한 곳의 변화가 다른곳에 미치는 영향 최소화

    * ex. 

      public → 클래스 외부 접근 o

      priviate → 클래스 내부 접근만 o

      protected → 상속받은 클래스에서만 o

  * 상속(Inheritance) = 일반화(Generalization)

    * 자식 클래스가 부모 클래스의 특정과 기능을 물려받음

    * 왜 필요? 캡슐화 & 클래스 재사용 용이하게 함

      →  자식 클래스 자체를 캡슐화하여 다른 외부 클래스 자식클래스들에 뭐가 있는지 정보 알 수 없음

  * 추상화(Abstaction)

    * 인터페이스
    * 클래스의 공통 특성(변수, 메소드)를 묶어 표현
    * 왜 필요? 새로운 하위 종류가 생기면 기존 것 수정 없이 새로 추가로 만들 부분만 생성하면 됨 

  * 다형성(Polymorphism)

    * 어떤 변수, 메소드가 상황에 따라 다른 결과 내는 것
    * 오버로딩 →  메소드 이름 같지만, 파라메터 다른 것 (리턴값만 다른 X)
    * 오버라이딩 → 부모 클래스의 메소드를 자식클래스 용도에 맞게 재정의
    * 왜 필요? 코드 간결 & 유연성



### 3. RESTful API

* REST(REpresentational State Transfer)

  * 자원의 이름(자원의 표현)으로 구분하여, 해당 자원의 상태(정보)를 주고받는 것

    * 자원

      →  문서, 그림, 데이터 등 해당 SW가 관리하는 모든 것

    * 자원의 표현

      →  그 자원을 표현하는 이름

      →  ex. 자원 (DB의 학생정보) =>  Students (자원의 표현)

    * 상태(정보) 전달

      →  데이터가 요청되는 시점에서 자원의 상태를 전달

  * HTTP URI(Uniform Resource Identifier)로 자원을 명시하고 
    & HTTP Method를 통해 해당 자원에 대한 CRUD를 적용하는 것

    * "HTTP URI로 자원을 명시"

      →  리소스

      ​	ㆍ  http://myweb/users 같은 URI로 표현

      ​	ㆍ  모두 명사로 표현되어야 함(세부 리소스에는 id붙임)

      →  행위

      ​	ㆍ  HTTP Method로 표현

      ​	ㆍ  GET/POST/PUT/PATCH/DELETE를 분명한 목적으로 사용

  * 구성

    * 자원

      →   URI로 표현되고, 클라이언트는 URI로 자원을 지정하여 해당 자원의 상태(정보)에 대한 조작을 서버에 요청

    * 행위

      →   HTTP Method를 사용

      →   자원에 이러한 행위를 해줘

    * 표현

      →   클라이언트가 자원의 상태(정보) 조작을 요청하면 서버는 이에 응답(표현)을 보냄

      →   자원 행위에 대한 내용

  * 장단점

    * 장점

      * 기존 웹 인프라(HTTP)를 그대로 사용

      * HTTP 표준 프로토콜을 따르는 모든 플랫폼 사용 가능

        →   멀티플랫폼 지원 및 연동이 용이

      * 원하는 타입으로 데이터 주고 받기 가능

        →   Json, form-data 등

    * 단점

      * 표준이 존재하지 않음

        →  데이터 타입, 통신 규격 등이 규정되지 않음 

      * 메소드가 4개다 전부

      * HTTP통신 모델에서만 지원

  * 6가지 원칙

    * Uniform Interface (인터페이스 일관성)

      →  하나의 URL로는 하나의 데이터만 가져옴

      →  URL만 보고 어떤 정보가 들어올 지 예측 가능하게

    * Stateless (무상태)

      →  HTTP요청의 작업을 위한 상태정보를 저장하지 않음

      →  컨텍스트를 유지해야하는 세션, 인증과 인가 정보 등 클라이언트에만 보관됨

      →  즉, 클리어언트의 모든 요청에는 해당 요청을 이해할 수 있는 모든 정보가 포함되야 함

      →  세션/쿠키 정보를 저장하지 않아 서버는 들어오는 요청만 처리하면 됨

    * Cacheable (캐시처리 가능)

      →  HTTP 를 사용하므로, HTTP가 가진 캐싱 기능 브라우저가 알아서 함

      →  요청으로 보내는 데이터들은 캐싱이 가능해야 함(성능 향상을 위해)

    * Client-Server (클라이이언트-서버 구조)

      →  클라이언트와 서버 역할 구분하여 서로 의존성 없이 개발되야 함

      →  클라이언트: 요청을 함 / 서버 : 응답함

    * Hierarchical system /Layred system (계층화)

      →  REST 서버는 다중 계층으로 구성될 수 있음

      →  각 레이어는 자신이 통신하는 컴포넌트 외 레이어의 정보 얻기 불가능

      →  즉, 클라이언트는 REST 서버와만, REST가 상호작용하는 레이어 등 다른 곳에는 직접적으로 요청 불가능, 상호작용도 못봄

      →  ex. API서버, DB서버, 인증 서버를 따로 둘 수 있음

    * Code on demand (* 선택적)

      →  서버에서 코드를 클라이언트에게 보내 실행할 수 있어야 함

      →  ex. 서버로부터 받은 javascript파일을 브라우저에서 실행시킬 수 있다.

  * 필요한 이유

    * 다양한 브라우저, 안드로이드 폰, 아이폰 등 모바일 디바이스같은 다양한 클라이언트가 등장하였기에, 이러한 멀티 플랫폼에 대한 지원이 가능해서

* REST API

  * REST 기반으로 API구현한 것

    * API(Application Programming Interface)

      →   요청과 응답을 사용하여 두 애플리케이션 간 통신 방법 정의



### 4. TDD(Test-Driven Development; 테스트 주도 개발) 

* 개발 코드 작성 전 테스트 코드를 먼저 작성하는 개발 방법론
* 과정
  1. 한 가지 기능 내 한 가지 케이스의 테스트 작성
  2. 기능 구현된 것 없으므로 테스트 실패
  3. 실패한 테스트만 성공하는 최소한의 코드 작성
  4. 코드 리펙토링
     * 가독성을 위한 coding convention 맞추기
     * 예외 처리
     * 메소드가 한가지 일만 하도록 분리
     * 중복 최소화
  5. 다음 기능의 테스트 작성하고 다시 반복

* 왜 해야해?
  * 피드백과 협력이 자주 이루어짐
    * 피드백: 테스트 코드를 통해 테스트 통과인지 불통인지 자주 확인
    * 협력: 테스트 코드 공유할 수 있어서 다른사람들이 코드 의도 빠르게 이해 가능
  * 처음해보는 프로그램 주제
    * 나에대한 불확실성이 적은 경우
  * 고객 요구사항이 바뀔 수 있는 프로젝트
    * 외부적인 불확실성이 높은 경우
  * 개발 중 코드 수정이 많은 경우
  * 유지보수하는 사람과 개발하는 사람이 다를 경우

* 장단점

  * 장점

    * 테스트 작성을 위해선 요구사항 분석 & 이해 필요

      →   따라서 모든 요구사항에 집중하게 함

    * 유닛테스팅 덕에 특정 버그 찾기 쉬움 →  디버깅 시간 단축

    * 새로운 기능 추가 시, 추가 후에도 기존 테스트가 잘 작동하는 지 검사 가능

    * 테스트 문서 대체 가능

  * 단점

    * 코드 생산성 저하

      →  개발코드 & 테스트코드 2개를 짜야해서

      →  중간마다 테스트하며 고쳐나가야 해서



### 5. 함수형 프로그래밍

- 순수함수를 조합함으로써, 공유/변경 가능한 데이터와 부작용을 예방하여 SW만드는 프로세스

  - 순수함수를 조합하여 부수효과 줄이고 모듈화 수준을 높임

  - 순수함수(Pure functions)

    - 반드시 하나 이상의 인자를 받아, 받은 인자만 처리해 반드시 결과물 돌려줌

    - 인자 외 다른 변수 사용 금지 = 숨겨진 입출력 제거

      ```javascript
      var arr = [1,2,3,4,5]
      var condition = function(x) { return x%2==0; }
      
      // 순수함수 x
      var ex = function(array) {
          return array.filter(condition)	// 받은 인자 array아닌 conditiont사용
      };
      ex(arr);
      
      
      // 순수 함수
      var ex = function(array, cond) {
          return array.filter(cond)	// array, cond = 인자
      };
      ex(arr, condition)
      
      ```

- 애플리케이션 상태가 공유되고 객체 메서드와 함께 배치되는 OOP와 대조

- 선언형 프로그래밍 (반응형 프로그래밍)

  * How보다는 What을 설명하는 방식(무엇을 할 건지 표현)
  * 알고리즘을 명시하지 않고 목표만 명시
  * cf. 명령형 프로그래밍
    * 절차지향, 객체지향
    * 알고리즘 명시 (어떻게 할지 표현)

- java에서 함수형 프로그래밍

  - 람다식, stream api, 함수형 인터페이스

    ```java
    List<String> myList = Arrays.asList("a", "b", "c", "d", "e");
    
    // 기존방식 : 데이터 처리 방식이 한 눈에 보임 
    for(int i=0; i<myList.size(); i++){
    	String s = myList.get(i);
        if(s.startsWith("c")){
        	System.out.println(s.toUpperCase());
    	}
    }
    
    // stream API를 이용한 방식 : 한 눈에 내가 무엇을 구현했는지 알 수 있음
    myList.stream()
    	.filter(s -> s.startsWith("c"))
    	.map(String::toUpperCase)
    	.forEach(System.out::println);
    ```



