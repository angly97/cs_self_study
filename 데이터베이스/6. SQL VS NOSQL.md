# 6. SQL VS NOSQL



### 1. SQL

* RDBMS(관계형 데이터베이스 시스템)에서 데이터 관리하는 언어

  * 관계형 데이터베이스

    * 스키마가 정해져 있어서, 이 스키마에 맞는 데이터만 테이블에 저장

    * 테이블은 다른 테이블과 관계를 이룰 수 있음

* 장점

  * 정해진 스키마가 있어, 명확함
  * 관계를 통해 데이터 중복없이, 여러 곳에서 이용 가능
  * 제약조건을 통해 데이터 무결성 보장

* 단점

  * **DB 스키마를 변경하는 것이 어려움**
  * Join이 많이 발생할 수 있음
  * 수직확장만 가능하기 때문에 => 어느 시점에선 한계가 옴

* 사용 경우

  * 데이터 구조는 크게 변하지 않는 경우
  * 데이터 중복이 없기 때문에, 변경이 쉬움 => 데이터가 자주 변경되는 경우

* RDBMS의 한계

  * **데이터 변경을 위한 트랜잭션이 자주 일어나므로 => Lock 자주 발생**
  * **데이터가 많아지는데 분산처리는 어려움**
    * 테이블 분리하는 과정에서 스키마 변형 옴
    * 무결성/일관성을 유지하기 위해 네트워크 분할 허용성이 약함 

* ex. MySQL

  

### 2. NOSQL

* 비관계형 데이터베이스

  * 스키마 & 관계 없어서 => 분산된 데이터 관리하는데 특화된 데이터베이스

    > 왜 스키마 없는게 분산에 특화됨 ? 
    >
    > :  만약, 정해진 스키마가 있으면, 그 데이터 종류에 맞는 테이블로 가서 저장되야 하지만, 
    >
    >    스키마가 없으면, 모든 종류의 데이터를 그 노드에 저장 가능
  
* 장점
  * 스키마가 없어 유연
  
    * 저장된 데이터에 새로운 필드 추가 가능
  
    * 다른 구조의 데이터를, 같은 문서에 저장 가능 => 조인 없이 한 문서에서 조회
  
      > 그래서 NOSQL에는 조인 없음 
  
  * **수직/수평 확장** 모두가능하여, 많은 RW 요청 처리를 할 수 있음
  
* 단점
  * **중복된 데이터 수정 시, 그 데이터가 있는 모든 곳에서 다 수정해야함**
  * 대부분의 NoSQL이 **트랜잭션 지원 안해서**, 대규모의 데이터 접근 시 정합성 보장 불가
    * **분산에 특화되어서, 데이터 무결성을 약화시켰기 때문에**
  
* 사용 경우
  * 요구사항이 명확하지 않아, 데이터 구조가 자주 변경될 경우
  * 조회는 자주하지만, 중복된 데이터 변경은 적은 경우
  * **대용량 데이터를 다뤄서 RW요청**이 많아, **수평 확장/분산**이 필요한 경우

* ex. 몽고 DB

* NoSQL 데이터 베이스 모델 종류

  * Key-Value Model
    * 키-값 구조로 데이터 저장하는 방식
    
    * 키로 조회하니까 조회는 매우 빠르지만, 부등호 연산으로 같은 복잡한 조회 불가
    
    * **세션/쿠키 정보 저장에 사용**
    
    * ex. Redis 
    
      →   메모리 키-값 구조 저장소
    
      > 보통 DB는 하드디스크에 저장되지만, Redis는 메모리(RAM)에 저장하여 디스크 접근 없이 빠른 조회 가능
      >
      > 휘발성이므로 서버가 꺼지는 경우를 대비하여 디스크에 백업
    
      →   예시
    
      > 캐싱 : DB에 요청한 데이터를 저장해 두어서 디스크 IO를 줄임
      >
      > 세션 관리 :  메모리를 통해 매우 빠르게 세션정보를 가져옴
    
      →  if  RDBMS에 저장한다면, SELECT WHERE로 조회하기 때문에
    
      ​				데이터가 쌓일 수록, 키로 조회하는 것 보다 오래 걸림
    
  * Document Model
  
    * 하나의 키 값에 하나의 구조화 된 문서 저장하고, 그 문서 내에서 또 키-값들로 저장 가능
  
      > JSON, XML 같은 문서
  
    * **데이터 접근 방법이 관계형 데이터베이스와 유사함**
  
      > 문서 저장과 동시에, 문서 ID에 대한 인덱스가 생성되고,  B Tree 구조로 저장되어 있기 때문에
      >
      > ​	<img src="https://user-images.githubusercontent.com/70613905/177264394-55f06eef-fa25-40c1-bade-cf248f49cc86.jpg" alt="image-20220705153302580" style="zoom:67%;" />
  
    * 서로 특성이 다른 회원들을 한 문서에 저장하거나, 통계정보같은 대용량 데이터에 사용
  
    * ex. 몽고 DB



### 3. CAP 이론

* 분산 시스템의 속성으로, 보통 CAP 중 2가지만 만족시킴

* 일관성 (Consistency)

  * 다중 클라이언트(분산된 노드)에서 같은 시간에 같은 데이터를 조회하면 결과는 같다.

  * **RDBMS에선 트랜잭션을 통해 가능**

  * **NoSQL에선 Eventually Consistency(궁극적 일관성) 으로 가능**

    * 궁극적 일관성

      →  실시간 동기화는 아니라서 당장은 맞지 않지만, 결국 언젠가 동기화되서 일관성이 맞춰지는 것

    *  동기식

      →  데이터 저장 결과를 응답 전에, 모든 노드에 데이터를 저장

      →  **응답 시간 느리지만** 데이터 정합성 보장

    * 비동기식

      →   메모리나 임시 파일에 기록 후, 클라이언트에 먼저 응답하고 노드들에 데이터 저장
    
      →   **빠른 응답시간** & 다른 노드에 동기화할 때, 쓰기에 장애 발생 시 데이터 손실

* 가용성 (Availability, 내고장성)

  * 클러스터 내 몇 개의 노드가 망가져도 서비스 가능해서 **모든 RW요청에 항상 응답 가능함**

  * 데이터 복제(Replication) 즉, 중복 저장을 통해 보장 가능

    * Master-Slave

      →   Master 저장소를 Slave들에 복제

      →   master가 실패해도 slave로 읽기 요청 가능

      →   읽기 요청이 많을 때는, slave들이 처리하여 수평 확장 가능

      →   쓰기 요청이 많은 경우에는 무조건 Master에만 쓸 수 있으니까 별로 효과 X

    * Peer-To-Peer

      →   마스터를 두지 않고, 모든 복제본의 가중치는 동일

      →   모든 노드에서 RW 요청 처리 가능, 한 곳에서 쓰기 후 다른 노드들에 복제

      →   읽기, 쓰기 요청에 모두 효과 있음

      →  **근데 동일 레코드에 2명이 쓰기 요청하면** 쓰기 충돌 발생 => **정합성 보장 불가**

* 분할 허용성(Partition Tolerance)

  * 노드 간 네트워크 연결이 끊어져도 서비스 가능

* 특성에 따른 데이터베이스 종류

  * CA DB

    * **분산보다는, 데이터 일관성 & 가용성에 중점을 두어서 => 데이터 신뢰성 중요**

    * C : 트랜잭션의 ACID를 통해 일관성 유지

    * **A : 복제**

    * **P : 샤딩으로 테이블을 나누면, 데이터 관계가 무너질 수 있음**

    * 관계형 데이터베이스

    * **사용 경우: 데이터 신뢰성이 중요해서 트랜잭션이 필요한 경우**

  * CP DB

    * 가용성을 희생

    * 두 노드 간 파티션이 발생하면, 파티션 해결될 때까지 일관되지 않은 노드 종료

    * Redis, Mongo DB

    * 사용 경우

      →   모든 노드가 함께 일관된 답을 내야하는 경우 (ex. 최신정보를 여러 클라이언트에 제공하는 경우; 각 나라의 실시간 검색어?)

  * AP DB

    * 일관성 희생

    * 파티션 발생해도, 모든 노드를 계속 사용할 수 있지만, 특정 노드는 최신 데이터가 아니라, 그 이전 데이터를 반환할 수 있음

    * 파티션이 해결되면, 노드를 다시 동기화하여, 불일치를 복구

    * Dynamo DB, 카산드라 DB

    * 사용 경우

      →   늘 가장 최신 정보를 받는 것은 아니어도 되면서,  대용량의 데이터를 처리하는 경우 => 여러 분산된 곳에 여러 서버를 이용하기 때문에

