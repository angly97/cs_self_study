# 6. SQL VS NOSQL



### 1. SQL

* RDBMS(관계형 데이터베이스 시스템)에서 데이터 관리하는 언어

  * 관계형 데이터베이스

    * **스키마가 정해져 있어서**, 이 스키마에 맞는 데이터만 테이블에 저장

    * 테이블은 다른 테이블과 관계를 이룰 수 있음

* 장점

  * 정해진 스키마가 있어, 명확함
  * 관계를 통해 데이터 중복없이, 여러 곳에서 이용 가능
  * **제약조건을 통해 데이터 무결성 보장**

* 단점

  * DB 스키마를 변경하는 것이 어려움
  * Join이 많이 발생할 수 있음
  * **수직확장**만 가능하기 때문에 => 어느 시점에선 한계가 옴

* 사용 경우

  * 데이터가 자주 변경되는 경우
  * 데이터 구조는 크게 변하지 않는 경우

* ex. MySQL

  

### 2. NOSQL

* 비관계형 DBMS의 언어

  * 비관계형 데이터베이스

    * 스키마 & 관계 없어서 => 분산된 데이터 관리하는데 특화된 데이터베이스

      > 왜 스키마 없는게 분산에 특화됨 ? 
      >
      > :  만약, 정해진 스키마가 있으면, 그 데이터 종류에 맞는 테이블로 가서 저장되야 하지만, 
      >
      >    스키마가 없으면, 모든 종류의 데이터를 그 노드에 저장 가능

    
    * 문서(Documents) = RDB의 레코드
  
* 장점
  * 스키마가 없어 유연
  
    * 저장된 데이터에 새로운 필드 추가 가능
  
    * 다른 구조의 데이터를, 같은 문서에 저장 가능 => 조인 없이 한 문서에서 조회
  
      > 그래서 NOSQL에는 조인 없음 
  
  * **수직/수평 확장** 모두가능하여, RW 요청 처리를 할 수 있음
  
* 단점
  * 관계가 된 데이터를 수정 시, 관계를 맺은 다른 문서에서도 수정해야함
  * 대부분의 NoSQL이 **트랜잭션 지원 안해서**, 대규모의 데이터 접근 시 정합성 보장 불가

* 사용 경우
  * 요구사항이 명확하지 않아, 데이터 구조가 자주 변경될 경우
  * 조회는 자주하지만, 관계를 맺고있는 데이터 변경은 적은 경우
  * **대용량 데이터를 다뤄서 RW요청**이 많아, 수평 확장이 필요한 경우

* ex. 몽고 DB

* NoSQL 데이터 베이스 모델 종류

  * Key-Value Model
    * 키-값 구조로 데이터 저장하는 방식
    
    * 키로 조회하니까 조회는 매우 빠르지만, 부등호 연산으로 같은 복잡한 조회 불가
    
    * 세션정보 등 저장에 사용
    
    * ex. Redis 
    
      ▼   메모리 키-값 구조 저장소
    
      ​	→   보통 DB는 하드디스크에 저장되지만, Redis는 메모리(RAM)에 저장하여 디스크 접근 없이 빠른 조회 가능
      
      ​	→   휘발성이므로 서버가 꺼지는 경우를 대비하여 디스크에 백업
      
      ▼   value 자료형
      
      ​	→   String / set / sorted set / Hash / List
      
      ▼    예시
      
      ​	→   캐싱
      
      ​		ㆍ  DB에 요청한 데이터를 저장해 두어서 디스크 IO를 줄임
      
      ​	→   세션 관리
      
      ​		ㆍ  메모리를 읽음으로써 매우 빠르게 세션정보를 가져옴
      
      ​		ㆍ  if  RDBMS에 저장한다면, SELECT WHERE로 조회 => 데이터가 쌓일 수록, 키로 조회하는 것 보단 조회성능 떨어짐		      
    
  * Document Model
    * 하나의 키 값에 하나의 구조화 된 문서 저장하고, 그 문서 내에서 또 키-값들로 저장 가능
    * 키 = 문서의 ID
    * 데이터 접근 방법이 RDB와 유사
    * 저장된 문서는 컬렉션으로 관리하고, 문서 저장과 동시에 문서 ID에 대한 인덱스 생성
    * 인덱스로 O(1) 시간으로 문서 조회
    * B Tree 구조로 구성
    * 서로 특성이 다른 회원들을 한 문서에 저장하거나, 통계정보같은 대용량 데이터에 사용
    * ex. 몽고 DB



### 3. CAP 이론

* 분산 시스템의 속성으로, 보통 CAP 중 2가지만 만족시킴

* 일관성 (Consistency)

  * 다중 클라이언트(분산된 노드)에서 같은 시간에 같은 데이터를 조회하면 결과는 같다.

  * RDBMS에선 트랜잭션을 통해 가능

  * NoSQL에선 Eventually Consistency로 데이터 동기화하여 가능, 데이터 동기화 방법 ↓

    * Eventually Consistency : 실시간 동기화는 아니기 때문에 당장은 맞지 않지만, 결국 언젠가 데이터가 동기화되어 일관성이 맞춰지는 것

    ▼   동기식

    ​	→   데이터 저장 결과를 응답 전에, 모든 노드에 데이터를 저장

    ​	→   응답 시간 느리지만 데이터 정합성 보장

    ▼   비동기식

    ​	→   메모리나 임시 파일에 기록 후, 클라이언트에 먼저 응답하고 노드들에 데이터 저장

    ​	→   빠른 응답시간 & 다른 노드에 동기화할 때, 쓰기에 장애 발생 시 데이터 손실

* 가용성 (Availability, 내고장성)

  * 클러스터 내 몇 개의 노드가 망가져도 서비스 가능해서 모든 RW요청에 항상 응답 가능함

  * 데이터 복제(Replication) 즉, 중복 저장을 통해 보장 가능

    ▼   Master-Slave

    ​	→   Master 저장소를 Slave들에 복제

    ​	→   master가 실패해도 slave로 읽기 요청 가능

    ​	→   읽기 요청이 많을 때는, slave들이 처리하여 수평 확장 가능

    ​	→   쓰기 요청이 많은 경우에는 무조건 Master에만 쓸 수 있으니까 별로 효과 X

    ▼   Peer-To-Peer

    ​	→   마스터를 두지 않고, 모든 복제본의 가중치는 동일

    ​	→   모든 노드에서 RW 요청 처리 가능, 한 곳에서 쓰기 후 다른 노드들에 복제

    ​	→   읽기, 쓰기 요청에 모두 효과 있음

    ​	→  **근데 동일 레코드에 2명이 쓰기 요청하면** 쓰기 충돌 발생 => 정합성 보장 불가

* 분할 허용성(Partition Tolerance)

  * 노드 간 네트워크 연결이 끊어져도 서비스 가능

* 특성에 따른 데이터베이스 종류

  * CA DB

    * 분산보다는, 데이터 일관성 & 가용성에 중점을 두어서 => 데이터 신뢰성 중요

    * C : 트랜잭션의 ACID를 통해 일관성 유지

    * A : 복제

    * P : 샤딩으로 테이블을 나누면, 데이터 관계가 무너질 수 있음

    * RDBMS

    * 사용 경우

      →   데이터 신뢰성이 중요하여 트랜잭션이 필요한 경우

  * CP DB

    * 가용성을 희생

    * 두 노드 간 파티션이 발생하면, 파티션 해결될 때까지 일관되지 않은 노드 종료

    * Redis, Mongo DB

    * 사용 경우

      →   모든 노드가 함께 일관된 답을 내야하는 경우 (ex. 최신정보를 여러 클라이언트에 제공하는 실시간 검색어?)

  * AP DB

    * 일관성 희생

    * 파티션 발생해도, 모든 노드를 계속 사용할 수 있지만, 특정 노드는 최신 데이터가 아니라, 그 이전 데이터를 반환할 수 있음

    * 파티션이 해결되면, AP DB는 노드를 다시 동기화하여, 불일치를 복구

    * Dynamo DB, 카산드라 DB

    * 사용 경우

      →   여러 분산된 곳에 여러 서버를 이용하기에 => 대용량을 데이터를 처리할 때 사용

      

### 4. 데이터베이스 확장

* 수직 확장 (Scale Up)

  * 데이터베이스 성능을 업그레이드 => 일정 수준 이상의 접근이 오면 한계가 와

  * ex. 저장장치를 업그레이드 등

  * SQL은 수직확장만 지원
    * 수평확장은 파티셔닝을 수행하는 데 이때 스키마에 변형이 오기 때문에 SQL은 불가능

* 수평 확장 (Scale Out)

  * **서버를 늘려 서버의 부하를** DB 전체에 분산시킴
  
  * DB를 분산시킬 때는 파티셔닝을 수행
  
    * 수직 파티셔닝
  
      →   테이블의 몇몇 속성을 분리 => 스키마 변형이 옴
  
    * 수평 파티셔닝
  
      →   레코드를 나눠서 분리 => 스키마는 유지
  
  * 한 데이터베이스에서 작동하지만 여러 호스트에서 작동
  
  * NoSQL은 수직/수평 확장 모두 가능