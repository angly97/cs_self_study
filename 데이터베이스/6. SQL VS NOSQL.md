# 6. SQL VS NOSQL



### 1. SQL

* RDBMS(관계형 데이터베이스 시스템)에서 데이터 관리하는 언어

  * 관계형 데이터베이스

    * 스키마가 정해져 있어서, 이 스키마에 맞는 데이터만 테이블에 저장

    * 테이블은 다른 테이블과 관계를 이룰 수 있음

* 장점

  * 정해진 스키마가 있어, 명확함
  * 관계를 통해 데이터 중복없이, 여러 곳에서 이용 가능
  * **제약조건을 통해 데이터 무결성 보장**

* 단점

  * DB 스키마를 변경하는 것이 어려움
  * Join이 많이 발생할 수 있음
  * **수직확장**만 가능하기 때문에 => 어느 시점에선 한계가 옴

* 사용 경우

  * 데이터가 자주 변경되는 경우
  * 데이터 구조는 크게 변하지 않는 경우

* ex. MySQL

  

### 2. NOSQL

* 비관계형 DBMS의 언어

  * 비관계형 데이터베이스

    * 스키마 & 관계 없어서 => 분산된 데이터 관리하는데 특화된 데이터베이스

      > 왜 스키마 없는게 분산에 특화됨 ? 
      >
      > :  만약, 정해진 스키마가 있으면, 그 데이터 종류에 맞는 테이블로 가서 저장되야 하지만, 
      >
      >    스키마가 없으면, 모든 종류의 데이터를 그 노드에 저장 가능

    
    * 문서(Documents) = RDB의 레코드
  
* 장점
  * 스키마가 없어 유연
  
    * 저장된 데이터에 새로운 필드 추가 가능
  
    * 다른 구조의 데이터를, 같은 문서에 저장 가능 => 조인 없이 한 문서에서 조회
  
      > 그래서 NOSQL에는 조인 없음 
  
  * **수직/수평 확장** 모두가능하여, RW 요청 처리를 할 수 있음
  
* 단점
  * 관계가 된 데이터를 수정 시, 관계를 맺은 다른 문서에서도 수정해야함
  * 대부분의 NoSQL이 **트랜잭션 지원 안해서**, 대규모의 데이터 접근 시 정합성 보장 불가

* 사용 경우
  * 요구사항이 명확하지 않아, 데이터 구조가 자주 변경될 경우
  * 조회는 자주하지만, 관계를 맺고있는 데이터 변경은 적은 경우
  * **대용량 데이터를 다뤄서 RW요청**이 많아, 수평 확장이 필요한 경우

* ex. 몽고 DB

* 특성 (CAP 이론)

  * 분산 데이터베이스의 속성으로, 분산 시스템은 CAP 중 2가지만 만족시킴

  * 일반적으로, 네트워크 분단이 생겼을 때, 일관성과 가용성 중 1개는 희생해야 한다는 의미

    * 네트워크가 중단되면 아예 서비스를 안하거나, 각각의 네트워크에서 데이터는 다르지만 서비스는 하거나

  * 일관성 (Consistency)

    * 다중 클라이언트(분산된 노드)에서 같은 시간에 같은 데이터를 조회하면 결과는 같다.

    * 분산된 노드 간 데이터 동기화하여 가능, 데이터 동기화 방법 ↓

      ▼   동기식

      ​	→   데이터 저장 결과를 응답 전에, 모든 노드에 데이터를 저장
      
      ​	→   응답 시간 느리지만 데이터 정합성 보장
      
      ▼   비동기식
      
      ​	→   메모리나 임시 파일에 기록 후, 클라이언트에 먼저 응답하고 노드들에 데이터 저장
      
      ​	→   빠른 응답시간 & 다른 노드에 동기화할 때, 쓰기에 장애 발생 시 데이터 손실

  * 가용성 (Availability, 내고장성)

    * 클러스터 내 몇 개의 노드가 망가져도 서비스 가능해서 모든 RW요청에 항상 응답 가능함

    * 데이터 복제(Replication) 즉, 중복 저장을 통해 보장 가능

      ▼   Master-Slave

      ​	→   Master 저장소를 Slave들에 복제
      
      ​	→   master가 실패해도 slave로 읽기 요청 가능
      
      ​	→   읽기 요청이 많을 때는, slave들이 처리하여 수평 확장 가능
      
      ​	→   쓰기 요청이 많은 경우에는 무조건 Master에만 쓸 수 있으니까 별로 효과 X
      
      ▼   Peer-To-Peer
      
      ​	→   마스터를 두지 않고, 모든 복제본의 가중치는 동일
      
      ​	→   모든 노드에서 RW 요청 처리 가능, 한 곳에서 쓰기 후 다른 노드들에 복제
      
      ​	→   읽기, 쓰기 요청에 모두 효과 있음
      
      ​	→  **근데 동일 레코드에 2명이 쓰기 요청하면** 쓰기 충돌 발생 => 정합성 보장 불가

  * 분할 허용성(Partition Tolerance)

    * 노드 간 네트워크 장애가 발생해도 서비스 가능

* NoSQL 데이터 베이스 모델 종류

  * Key-Value Model
    * 키-값 구조로 데이터 저장하는 방식
    
    * 키로 조회하니까 조회는 매우 빠르지만, 부등호 연산으로 같은 복잡한 조회 불가
    
    * 세션정보 등 저장에 사용
    
    * ex. Redis 
    
      ▼   메모리 키-값 구조 저장소
    
      ​	→   보통 DB는 하드디스크에 저장되지만, Redis는 메모리(RAM)에 저장하여 디스크 접근 없이 빠른 조회 가능
      
      ​	→   휘발성이므로 서버가 꺼지는 경우를 대비하여 디스크에 백업
      
      ▼   value 자료형
      
      ​	→   String / set / sorted set / Hash / List
      
      ▼    예시
      
      ​	→   최근 방문 기록
      
      ​		ㆍ  로그인 id를 키값으로해서 최근 방문한 10개 사이트 저장
      
      ​		ㆍ  if not NoSQL, RDBMS에 방문기록 테이블을 저장하여, WHERE id = ''로 SELECT 조회
      ​		ㆍ  이 경우, 데이터가 쌓일 수록, 키로 조회하는 것 보단 조회성능 떨어짐		      
    
  * Document Model
    * 하나의 키 값에 하나의 구조화 된 문서 저장하고, 그 문서 내에서 또 키-값들로 저장 가능
    * 키 = 문서의 ID
    * 데이터 접근 방법이 RDB와 유사
    * 저장된 문서는 컬렉션으로 관리하고, 문서 저장과 동시에 문서 ID에 대한 인덱스 생성
    * 인덱스로 O(1) 시간으로 문서 조회
    * B Tree 구조로 구성
    * 서로 특성이 다른 회원들을 한 문서에 저장하거나, 통계정보같은 대용량 데이터에 사용
    * ex. 몽고 DB



### 3. 데이터베이스 확장

* 수직 확장 (Scale Up)

  * 데이터베이스 성능을 업그레이드 => 일정 수준 이상의 접근이 오면 한계가 와

  * ex. 저장장치를 업그레이드 등

  * SQL은 수직확장만 지원
    * 수평확장은 파티셔닝을 수행하는 데 이때 스키마에 변형이 오기 때문에 SQL은 불가능

* 수평 확장 (Scale Out)

  * **서버를 늘려 서버의 부하를** DB 전체에 분산시킴
  
  * DB를 분산시킬 때는 파티셔닝을 수행
  
    * 수직 파티셔닝
  
      →   테이블의 몇몇 속성을 분리 => 스키마 변형이 옴
  
    * 수평 파티셔닝
  
      →   레코드를 나눠서 분리 => 스키마는 유지
  
  * 한 데이터베이스에서 작동하지만 여러 호스트에서 작동
  
  * NoSQL은 수직/수평 확장 모두 가능