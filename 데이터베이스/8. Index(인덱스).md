# 8. Index(인덱스)



### 1. 인덱스

* 컬럼과 레코드 주소를 키-값 쌍들로 만들어 B+ Tree 구조로 저장한 것

  * 늘 정렬된 상태를 유지하기에, 검색은 빠르지만, 값 추가/삭제는 느림
  * RDBMS에서 디스크 IO를 줄여, 검색 속도를 높이기 위함

* 인덱스의 자료구조

  * Hash

    * 컬럼 값은 해시 값으로 계산 후 인덱싱
    * 해시함수만 거치면 키를 찾을 수 있기에, 매우 빠른 검색 지원
    * 값을 일부만 가지고 검색하는 경우/범위 검색/정렬 결과 검색에는 사용 불가

  * B+ Tree

    * 컬럼 값 변형 없음

    * 일반적으로 사용되는 구조

      →   해시 테이블은 = (Equal)연산만 가능하지만, 질의 조건에는 부등호 연산도 포함되기 때문에

* 종류

  * Clustered Index / Primary Index
    * 테이블 PK 값이 비슷한 레코드(실제 디스크 블록)를 묶어 한 인덱스로 저장
    * PK값에 의해 인덱스 저장 위치 결정되고, PK 변경 시, 레코드의 물리적인 저장 위치도 변경됨
    * 데이터 삽입/삭제 시마다 데이터 정렬됨
    * 한 테이블 당 한 개

  * Secondary Index (보조 인덱스)
    * PK 이외 필요한 정렬기준이 있을 경우 사용
      * 모든 레코드의 주소를 가짐 => Clustered보다 더 많은 공간 필요
      * 정렬되지 않은 상태
      * 한 테이블 당 여러개

* 생성과정

  * Table 생성 시, MYD, MYI, FRM 3개 파일 생성
    * MYD : 실제 데이터 있는 파일
    * MYI : Index 정보 있는 파일
    * FRM : 테이블 구조 저장된 파일
  * 인덱스 사용 안하는 경우 MYI는 비어져 있음
    * 인덱싱할 때 MYI 파일 생성됨
  * 이 후, 사용자가 Select 쿼리로 Index 사용하는 Column 탐색 시, MYI 파일 내용 검색

* 단점

  * 인덱스 생성 시, .mdb 파일 크기 증가
  * 한 페이지를 동시에 수정할 수 있는 병행성 줄어듬
  * 인덱스 된 데이터 Insert/Update/Delete 시 성능 저하
  * 데이터 변경 작업 많은 경우 Index 재작성해야하므로 성능 영향 미침



### 2. 인덱스 성능 & 고려사항

* 인덱스 성능은 Select 에 좋고, Insert/Update/Delete에 안 좋음
  * Insert
    * 데이터 추가 시, 인덱스에 대한 데이터 추가 & 정렬
  * Delete
    * 데이터는 삭제하지만, 인덱스의 데이터는 삭제 안하고, 사용 안한다는 표시함
    * 즉, row 수는 그대로 => 실 데이터는 10인데 100이 저장되어있는 낭비 발생
  * Update
    * Index는 Update가 없기에 새로 Insert하고, Delete처리함
    * 두 배 작업해야 함
    * 따라서 Insert문제 + Delete문제 동시 발생
* 인덱스가 되는 컬럼에 따라 성능 차이 발생
  * 범위가 너무 적은 컬럼 (ex. 성별)로 인덱스 만들면, 인덱스를 자주 읽게 되어 디스크 IO발생 증가



### 3. 상황 분석

* 사용하면 좋은 경우
  * Where절에 자주 사용되는 Column
  * Join에 자주 사용되는 Column (PK, FK)
* 사용 피할 경우
  * Data 중복도 높은 Column
  * DML 이 자주 일어나는 Column
    * DML이 일어나다 = 데이터 Insert/Update/Delete