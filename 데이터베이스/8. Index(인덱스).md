# 8. Index (인덱스)



### 1. 인덱스

* 컬럼과 레코드 주소를 키-값 쌍들로 만들어 B+ Tree 구조로 저장한 것

  * 늘 정렬된 상태를 유지하기에, 검색은 빠르지만, 값 추가/삭제는 느림
* 필요성/사용 이유/배경

  * **RDBMS에서 디스크 IO를 줄여, 검색 속도를 높이기 위함**
* 인덱스의 자료구조

  * Hash

    * 컬럼의 해시값을 키로 함
    * 해시함수만 거치면 키를 찾을 수 있기 때문에 => 검색 속도 매우 빠름
    * 하지만, 범위 검색이나 정렬 결과 검색은 불가

  * B+ Tree

    * 컬럼 값 변형 없음

    * 부등호 연산이나 정렬 조회 가능해서 => 일반적으로 사용됨

* 종류
  * https://m.blog.naver.com/islove8587/220431192221

  * Clustered Index / Primary Index
    * 테이블 PK 값이 비슷한 레코드(실제 디스크 블록)를 묶어 한 인덱스로 저장
    * 클러스터드 인덱스 순서로 레코드들이 하드디스크에 저장됨
    * 그렇기 때문에 PK 변경 시, 레코드의 물리적인 저장 위치도 변경됨
    * 데이터 삽입/삭제마다 데이터 정렬됨
    * 한 테이블 당 한 개

  * Non-Clusterd Index / Secondary Index (보조 인덱스)
    * PK 이외 필요한 정렬기준이 있을 경우 사용
    * 별도의 인덱스 테이블 생성 => 클러스터드 보다 용량 더 소모
    * 레코드 정렬은 안하고, 인덱스 테이블만 정렬된 상태
    * 인덱스 테이블에 실제 레코드 주소가 저장되어 있음
    * 데이터 삽입/삭제마다 재정렬하지 않아서, 검색은 느리지만 삽입/삭제는 빠름
    * 한 테이블 당 여러개

* 생성과정

  * Table 생성 시, MYD, MYI, FRM 3개 파일 생성
    * MYD (MYsqlData) : 실제 데이터 있는 파일
    * MYI (MYsql Index): Index 정보 있는 파일
    * FRM (FoRMat) : 테이블 구조 저장된 파일
  * 이 후, 사용자가 Select 쿼리로 Index를 사용해서 조회 시, MYI 파일 내용 검색
* 단점 / 인덱스 사용하지 않는 이유

  * 인덱스를 만들면, 인덱스 정보도 포함해야 하니까 .mdb 파일 크기 증가
  * 인덱스 된 데이터 Insert/Update/Delete 시 인덱스 재작성 되니까 성능 저하



### 2. 인덱스 성능 & 고려사항

* 인덱스 성능은 Select 에 좋고, Insert/Update/Delete에 안 좋음
  * Insert
    * 데이터 추가 시, 인덱스에 대한 데이터 추가 & 정렬
  * Delete
    * 데이터는 삭제하지만, 인덱스의 데이터는 삭제 안하고, 사용 안한다는 표시함
    * 즉, row 수는 그대로 => 실 데이터는 10인데 100이 저장되어있는 낭비 발생
  * Update
    * Index는 Update가 없기에 새로 Insert하고, Delete처리함
    * 두 배 작업해야 함
    * 따라서 Insert문제 + Delete문제 동시 발생
* 인덱스가 되는 컬럼에 따라 성능 차이 발생
  * 범위가 너무 적은 컬럼 (ex. 성별)로 인덱스 만들면, 성별 내에서 또 다시 탐색을 위한 디스크 IO가 필요



### 3. 상황 분석

* 사용하면 좋은 경우
  * Where절에 자주 사용되는 Column
  * Join에 자주 사용되는 Column (PK, FK)
* 사용 피할 경우
  * 성별처럼 Data 중복도 높은 Column
  * DML 이 자주 일어나는 Column
    * DML이 일어나다 = 데이터 Insert/Update/Delete