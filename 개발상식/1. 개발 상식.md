# 1. 개발 상식



### 1. 클린 코드 (좋은 코드)

* 가독성이 좋음
* 중복을 최소화
* 함수는 한가지 일만 수행
  * 여러 가지 일을 하면 다른 기능이 자신이 모르는 사이에 실행될 수 있음



### 2. 리팩토링

* 프로그램 외부 동작은 유지하고, 내부 코드를 개선하여 => 클린코드로 만듦
* 장점/목적
  * 가독성 높여서 이해하기 쉽게 함 => 개발 속도 증가
  * 효율 높임
  * 유지보수 원활
* 리팩토링 방법/필요한 코드
  * 이름이 모호한 코드
  * 중복되는 코드는 묶어서 정리
  * **데이터 접근 관리가 필요한 부분에 캡슐화 적용**
  * 단순화 시킬 수 있는 조건문이 있으면, 이를 더 쉽게 함
* 클린코드와 차이
  * 리팩토링의 결과가 클린코드
  * 클린코드는 설계부터 잘 이루어져 있어야 함
  * 리팩토링은 중간 결과물이 나온 이 후 개선하는 작업



### 3. 시큐어 코딩

* 소스코드에 존재하는 잠재적 보안 약점을 제거하는 것
* 보안 약점을 통해 아래 공격에 노출될 수 있음
  * SQL 인젝션으로 개인 정보 유출



### 4. 객체 지향 프로그래밍 (Object Oriendted Programming; OOP)

* 현실 세계 사물을 객체로 하고, 그 객체에서 개발에 필요한 특징을 뽑아 프로그래밍하는 것

* <=> 절차적/구조적 프로그래밍 (OOP 등장 배경/필요성)

  * 절차(프로시저) == 함수

  * 반복코드를 함수로 묶음 & But, 클래스는 없음

  * ex. 자동차 관리 프로그램

    * 차에 관한 변수와 함수를 따로 만들어야 함

      ​	→   많은 데이터 만들 때 구분이 힘듦 

    * 차에 관한 변수와 함수가 같은 위치에 있을 순 있지만, 논리적으로 묶여있진 못함

    * 이를 한번에 묶기 위한 패러다임 == OOP 

* 장점
  * 객체 단위로 코드가 나뉘어서
    * 코드 재사용 높음
    
    * 유지보수에 용이

* 단점

  * 객체가 캡슐화되어 격리된 상태기 때문에, 객체 간 정보 교환이 필요 => 처리 시간 오래 걸림

  * 변수와 함수를 포함하는 객체를 저장하기 때문에 => 메모리 사용량 커짐

* OOP 5원칙 (SOLID)

  * 단일 책임 원칙 (Single Responsibility Principle; SRP)

    * 한 클래스는 하나의 책임을 가짐

    * 시스템이 커지면 서로 많은 의존성을 갖는데, 수정 요청이 오면 수정할 대상 1개만 수정하면 됨

    * 낮은 결합도 => 유지보수가 좋음 & 테스트 쉬워짐

    * SRP 어긴 예 (https://yoongrammer.tistory.com/96)

      > 유저를 추가할 때, 클래스에 비밀번호 암호화 기능도 있다면, 
      >
      > User와 Car 클래스에서 비밀번호 암호화 함수가 각각 내부에 존재한다고 하면, 
      >
      > 암호방식을 바꿀 때, User와 Car 내부 암호화 함수를 모두 변경해야 함
      >
      > But, 문자열 클래스를 만들고, 여기에 공통 암호화 함수를 만들면, 이 함수만 변경하면 됨

  * 개방-폐쇄 원칙 (Open-Closed Principle; OCP) 

    * 확장(새로운 기능 추가)에는 열려있어야 하고, 변경에는 닫혀있어야 함
    * 기존 코드 수정 하지 않고, 새로운 기능 추가
    * 변경 발생 시, 수정을 최소화하기 위함
    * OCP 어긴 예 (https://yoongrammer.tistory.com/97?category=1046505)
    
      > FileStorage 클래스에, 오라클에 저장하는 함수와 MySQL에 저장하는 함수가 존재
      >
      > 새로운 종류의 DB가 생길 경우, FileStorage 클래스를 수정해야 함
      >
      > But, FileStorage 클래스에, DB에 저장하는 추상메소드 선언하고,
      >
      > FileStorage를 상속하여 => 오라클 클래스, MySQL 클래스를 따로 만들고, 그 내부의 추상메소드 save() 를 구현해준다.
      >
      > 이러면 클래스 수정 없이, 확장 가능 
    
  * 리스코프 치환 원칙 (Liskov Substitution Principle; LSP)

    * 상위 객체를 하위 객체로 치환해도 상위 타입을 사용하는 프로그램을 정상 작동
    * ex. 자동차의 하위 객체 = 현대 자동차 => 자동차에 적용되던 코드는 현대자동차에도 적용 가능
    * ex. 직사각형 사용하던 프로그램에, 정사각형 대입해도, 잘 작동

  * 인터페이스 분리 원칙 (Interface Segregation Principle; ISP)

    * 무의미한 메소드 구현 방지를 위해 인터페이스가 잘 분리되어서 => 클래스가 꼭 필요한 인터페이스만 구현하도록 함
    
    * ISP 어긴 예
    
      > Vehicle클래스 내부에 go(), fly() 함수가 존재
      >
      > 비행기 클래스와 Car 클래스가 Vehicle를 구현하면, Car는 날지 못해도 fly를 구현해야함
      >
      > But, Vehicle을 Movable로 바꾸고, 여기에 go()만 포함 + Flyable에는 fly()포함 
    
  * 의존 역전 원칙 (Dependency Inversion Principle; DIP)

    * 상위모듈이 하위모듈에 의존해선 안됨
    
    * 추상화에 의존하며, 추상화는 세부 사항에 의존해선 안됨
    
    * 상위 모듈이 하위 모듈에 대해 갖는 종속성을 최소화 => 유지보수 높임
    
    * DIP 어긴 예 (https://yoongrammer.tistory.com/100?category=1046505)
    
      > 계산기 클래스 내부에서, 덧셈 클래스 객체를 선언하여 덧셈하는 경우
      >
      > ```python
      > class Add:
      > 	def calculate(self, num1, num2):
      > 		ret = num1 + num2
      > 		print(f'{num1} + {num2} = {ret}')
      > 		return ret
      > 
      > class Calculator:
      > 	def start(self, num1, num2):
      > 		operation = Add()
      > 		operation.calculate(num1, num2)
      >         # Sub이 추가되는 위치
      > ```
      >
      > 뻴셈을 추가할 때, 계산기 클래스를 수정하여 뺄셈 클래스 객체도 추가해야 함
      >
      > But, 계산기 클래스가 덧셈, 뺄셈을 직접 이용하지 않고, Operation 클래스 객체를 인자로 받아 처리한 후에, 이 Operation 클래스를 덧셈, 뺄셈이 상속받아 구현되면
      >
      > ```python
      > class Operation(ABC):
      > 	def do(self, num1, num2):
      > 		pass
      > 
      > class Add(Operation):
      > 	def do(self, num1, num2):
      > 		return num1 + num2
      > 
      > class Sub(Operation):
      > 	def do(self, num1, num2):
      > 		return num1 - num2
      > 
      > class Calculator:
      > 	def __init__ (self, operation: Operation):
      > 		self.operation = operation
      > 	
      > 	def start(self, num1, num2):
      > 		self.operation.calculate(num1, num2)
      > 
      > if __name__ == '__main__':
      > 	operation = Add()
      > 	cal = Calculator(operation)
      > 	cal.start(1, 2)
      > ```
      >
      > 나중에 나눗셈이 추가되어도, 계산기 클래스는 수정할 필요 없음
      >
      > 그냥 나눗셈 클래스를 Operation 상속하여 새로 만들고 인자로 전달하면 됨

* 4가지 특징 (캡상추다)

  * 캡슐화 (Encapsulation)

    * 외부에 드러나지 않도록 변수와 메소드를 하나로 묶음

    * 왜 필요? 

      →  한 곳의 변화가 미치는 영향 최소화

    * ex. public / priviate / protected

  * 상속 (Inheritance) = 일반화 (Generalization)

    * 부모 클래스의 특성과 기능을 자식 클래스가 물려받음

    * 왜 필요?

      →  자식 클래스만 접근 가능하게 하는 등의 캡슐화
      
      →  부모 클래스 재사용
    
  * 추상화 (Abstaction)

    * 클래스의 공통 특성(변수, 메소드)를 묶어 표현

    * 추상 클래스 VS 인터페이스

      > 공통 : 객체 생성 못함

      →  추상 클래스

      > 1개 이상의 추상 메소드(선언부만 존재/구현부 x)와 멤버변수를 가짐
      >
      > 동일 부모를 갖는 클래스를 묶는 개념으로, 부모의 특성 상속 받아 기능을 확장시키는 게 목적
      >
      > 다중 상속 불가 (부모가 2명 이상)

      →  인터페이스

      > 모든 메소드가 추상 메소드
      >
      > 필드는 public static final 필드 => 구현 객체의 같은 동작을 보장하기 위한 목적
      >
      > 같은 인터페이스를 구현하는 객체는 같은 메소드를 가져서, 같은 동작을 한다는 걸 보장하는 목적
      >
      > 다중 상속 가능

    * 왜 필요? 

      →  **새로운 하위 종류가 생겨도 수정 없이, 코드 추가 **

  * 다형성 (Polymorphism)

    * 어떤 변수, 메소드가 상황에 따라 다른 결과 내는 것
    * 오버로딩 →  매개변수는 다르지만, 이름이 같은 함수들을 정의
    * 오버라이딩 → 부모 클래스의 메소드를 자식클래스에서 재정의
    * 왜 필요? 
    
      →  **코드 간결 & 유연성**



### 5. TDD (Test-Driven Development; 테스트 주도 개발) 

* 개발 코드 작성 전, 테스트 코드를 작성하는 개발 방법론
* 과정
  1. 한 가지 기능에 대한 테스트 작성
  2. 기능 구현된 것 없으므로 테스트 실패
  3. 실패한 테스트를 성공하는 최소한의 코드 구현
  4. 코드 리펙토링
     * 가독성을 위한 convention 맞추기
     * 중복 최소화
     * 메소드가 한가지 일만 하도록 분리
     * 예외 처리
  5. 다음 기능의 테스트 작성하고 다시 반복
* 필요성/하는 이유
  * 유지보수하는 사람 != 개발하는 사람이 다른 경우에도 필요
  * 최근 트렌드가 급변하고, 새로운 기술이 등장하는 등 불확실성이 커짐 => 피드백&협력 중요
    * 테스트 코드를 통해 테스트 결과에 대한 피드백을 주고 받을 수 있게 되었고,
    * 테스트 코드 공유함으로써, 다른 사람들이 그 코드를 왜 작성한건지 쉽게 이해 할 수 있게 됨
* 장점

  * **유닛테스팅** 덕에 특정 버그 찾기 쉬움

  * **새 기능 추가** 후, 기존 테스트가 잘 작동하는 지 검사 가능

  * **테스트 문서 대체 가능**
* 단점

  * 코드 생산성 저하
    * 개발코드 & 테스트코드 2개를 짜야해서



### 6. 함수형 프로그래밍

- 순수함수를 조합하여, 부수효과 줄여 부작용을 예방하면서 SW 만드는 프로세스

  - 순수함수(Pure functions)

    - 반드시 하나 이상의 인자를 받아, 받은 인자만 처리해 반드시 결과물 돌려줌

    - 인자 외 다른 변수 사용 금지 = 숨겨진 입출력 제거 => 부작용 감소

      ```javascript
      var arr = [1,2,3,4,5]
      var condition = function(x) { return x%2==0; }
      
      // 순수함수 x
      var ex = function(array) {
          return array.filter(condition)	// 받은 인자 array아닌 conditiont사용
      };
      ex(arr);
      
      
      // 순수 함수
      var ex = function(array, cond) {
          return array.filter(cond)	// array, cond = 인자
      };
      ex(arr, condition)
      
      ```
  
  - 부수효과
  
    - 변수에 새로운 값이 대입되어, 값이 변경됨
    - 인자 외 다른 변수를 사용
    - 예외나 오류 발생 등
  
- **선언형 프로그래밍 (반응형 프로그래밍)**

  * 알고리즘보다는 목표를 명

    > 배열.filter(); 필터링이 목적이다

  * <=> **명령형 프로그래밍**

    * 절차지향, 객체지향

    * 알고리즘 명시

      > for문으로 배열을 탐색하고, if문으로 조건 맞는 애들만 추출하는 식으로 알고리즘 확인 가능

* 필요성 (자바에서 함수형 프로그래밍 도입한 이유)
  * 함수 자체가 독립적이며, 변수가 변경되는 등의 부수효과가 없기 때문에 => 스레드 안전성 보장
  * **즉, 동기화 없이 병렬처리 가능**
