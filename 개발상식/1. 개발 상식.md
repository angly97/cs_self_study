# 1. 개발 상식



### 1. 클린 코드 (좋은 코드)

* 가독성이 좋음
* 중복을 최소화
* 함수는 한가지 일만 수행
  * 여러 가지 일을 하면 다른 기능이 자신이 모르는 사이에 실행될 수 있음



### 2. 리팩토링

* 프로그램 외부 동작은 유지하고, 내부 코드를 개선하여 => 클린코드로 만듦
* 장점/목적 (리목/리장 가효유; 이모/이장 가요~)
  * 가독성 높여서 이해하기 쉽게 함 => 개발 속도 증가
  * 효율 높임
  * 유지보수 원활
* 리팩토링 방법/필요한 코드
  * 이름이 모호한 코드
  * 중복되는 코드는 묶어서 정리
  * **데이터 접근 관리가 필요한 부분에 캡슐화 적용**
  * 단순화 시킬 수 있는 조건문이 있으면, 이를 더 쉽게 함
* 클린코드와 차이
  * 리팩토링의 결과가 클린코드
  * 클린코드는 설계부터 잘 이루어져 있어야 함
  * 리팩토링은 중간 결과물이 나온 이 후 개선하는 작업



### 3. 시큐어 코딩

* 소스코드에 존재하는 잠재적 보안 약점을 제거하는 것
* 보안 약점을 통해 아래 공격에 노출될 수 있음
  * SQL 인젝션으로 개인 정보 유출
  * 무작위 대입 공격 등



### 4. 객체 지향 프로그래밍 (Object Oriendted Programming; OOP)

* 현실 세계 사물을 객체로 하고, 그 객체에서 개발에 필요한 특징을 뽑아 프로그래밍하는 것

* <=> 절차적/구조적 프로그래밍 (OOP 등장 배경/필요성)

  * 반복코드를 함수로 묶음 & But, 클래스는 없음

  * ex. 자동차 관리 프로그램

    * 차에 관한 변수와 함수를 따로 만들어야 함

      ​	→   많은 데이터 만들 때 구분이 힘듦 

    * 차에 관한 변수와 함수가 같은 위치에 있을 순 있지만, 논리적으로 묶여있진 못함

    * 이를 한번에 묶기 위한 패러다임 == OOP

* 장점
  * 객체 단위로 코드가 나뉘어서
    * **코드 재사용 높음**
    
    * 유지보수에 용이

* 단점

  * 객체가 캡슐화되어 격리된 상태기 때문에, 객체 간 정보 교환이 필요 => 처리 시간 오래 걸림

  * 변수와 함수를 포함하는 객체를 저장하기 때문에 => 메모리 사용량 커짐

* OOP 5원칙 (SOLID)

  * 단일 책임 원칙 (Single Responsibility Principle; SRP)

    * 한 클래스는 하나의 책임을 가짐

    * 시스템이 커지면 서로 많은 의존성을 갖는데, 수정 요청이 오면 수정할 대상 1개만 수정하면 됨 => 유지보수가 좋음

    * SRP 어긴 예

      > 유저를 추가할 때, 클래스에 비밀번호 암호화 기능도 있다면, 
      >
      > 유저 속성을 추가할 때에도, 비밀번호 암호 방식을 변경하고 싶을 때에도 
      >
      > user 클래스를 변경하게 됨

  * 개방-폐쇄 원칙 (Open-Closed Principle; OCP) 

    * 확장(새로운 기능 추가)에는 열려있어야 하고, 변경에는 닫혀있어야 함
    * 기존 코드 수정 하지 않고, 새로운 기능 추가
    
  * 리스코프 치환 원칙 (Liskov Substitution Principle; LSP)

    * 상위 객체를 하위 객체로 치환해도 상위 타입을 사용하는 프로그램을 정상 작동
    * ex. 자동차의 하위 객체 = 현대 자동차 => 자동차에 적용되던 코드는 현대자동차에도 적용 가능

  * 인터페이스 분리 원칙 (Interface Segregation Principle; ISP)

    * 무의미한 메소드 구현 방지를 위해 인터페이스가 잘 분리되어서 => 클래스가 꼭 필요한 인터페이스만 구현하도록 함
    
  * 의존 역전 원칙 (Dependency Inversion Principle; DIP)

    * 상위모듈이 하위모듈에 의존해선 안됨
    * 고수준 모듈  →  변경이 없는 추상화된 클래스
    * 저수준 모듈  →  변하기 쉬운 구체적인 클래스
    * 둘 다 추상화에 의존하며, 추상화는 세부 사항에 의존해선 안됨
    * 상위 모듈이 하위 모듈에 의존해버리면, 상속하는 의미가 사라짐

* 4가지 특징 (캡상추다)

  * 캡슐화 (Encapsulation)

    * 외부에 드러나지 않도록 (정보 은닉) 변수와 메소드를 하나로 묶음

    * 왜 필요? 

      →  **한 곳의 변화가 미치는 영향 최소화**

    * ex. public / priviate / protected

  * 상속 (Inheritance) = 일반화 (Generalization)

    * 부모 클래스의 특성과 기능을 자식 클래스가 물려받음

    * 왜 필요?

      →  자식 클래스만 접근 가능하게 하는 등의 캡슐화
      
      →  부모 클래스 재사용
      
    * 부모의 특성 상속 받아 기능을 확장시키는 게 목적

  * 추상화 (Abstaction)

    * 클래스의 공통 특성(변수, 메소드)를 묶어 표현

    * 추상 클래스 VS 인터페이스

      →  추상 클래스

      > 인스턴스 생성 불가
      >
      > 1개 이상의 추상 메소드(선언부만 존재/구현부 x)와 멤버변수를 가짐
      >
      > 동일 부모를 갖는 클래스를 묶는 개념으로, 부모의 특성 상속 받아 기능을 확장시키는 게 목적
      >
      > 다중 상속 불가(부모가 2명 이상)

      →  인터페이스

      > 인스턴스 생성 불가
      >
      > 모든 메소드가 추상 메소드
      >
      > 필드는 public static final 필드 => 구현 객체의 같은 동작을 보장하기 위한 목적
      >
      > 같은 인터페이스를 구현하는 객체는 같은 메소드가 존재해서 같은 동작을 한다는 걸 보장하는 목적
      >
      > 다중 상속 가능

    * 왜 필요? 

      →  새로운 하위 종류가 생기면 기존 것 수정 없이, 추가될 부분 생성하면 됨 
      
    * 같은 인터페이스를 구현하는 객체는 같은 메소드가 존재해서 같은 동작을 한다는 걸 보장하는 목적

  * 다형성 (Polymorphism)
  
    * 어떤 변수, 메소드가 상황에 따라 다른 결과 내는 것
    * 오버로딩 →  매개변수는 다르지만, 이름이 같은 함수들을 정의
    * 오버라이딩 → 부모 클래스의 메소드를 자식클래스에서 재정의
    * 왜 필요? 
    
      →  **코드 간결 & 유연성**



### 5. TDD (Test-Driven Development; 테스트 주도 개발) 

* 개발 코드 작성 전, 테스트 코드를 작성하는 개발 방법론
* 과정
  1. 한 가지 기능에 대한 테스트 작성
  2. 기능 구현된 것 없으므로 테스트 실패
  3. 실패한 테스트를 성공하는 최소한의 코드 구현
  4. 코드 리펙토링
     * 가독성을 위한 convention 맞추기
     * 중복 최소화
     * 메소드가 한가지 일만 하도록 분리
     * 예외 처리
  5. 다음 기능의 테스트 작성하고 다시 반복
* 필요성/하는 이유
  * 유지보수하는 사람 != 개발하는 사람이 다른 경우에도 필요
  * SW의 사용자가 대중이 되면서, 새로운 기술의 등장이나, 급변하는 요구 사항 등 불확실성이 커짐 => **피드백&협력 중요**
    * 테스트 코드를 통해 테스트 결과에 대한 피드백을 주고 받을 수 있게 되었고,
    * 테스트 코드 공유할 수 있어서 다른 사람들이 코드 의도를 쉽게 이해 할 수 있게 됨
* 장점

  * 테스트 작성을 위한 요구사항 분석에 집중하게 함

  * 유닛테스팅 덕에 특정 버그 찾기 쉬움 →  디버깅 시간 단축

  * 새 기능 추가 후, 기존 테스트가 잘 작동하는 지 검사 가능

  * 테스트 문서 대체 가능
* 단점

  * 코드 생산성 저하
    * 개발코드 & 테스트코드 2개를 짜야해서
    * 중간마다 테스트하며 고쳐나가야 해서



### 6. 함수형 프로그래밍

- 순수함수를 조합하여, 인자 값 변경하는 등의 부수효과 줄여 부작용을 예방하면서 SW 만드는 프로세스

  - 순수함수(Pure functions)

    - 반드시 하나 이상의 인자를 받아, 받은 인자**만** 처리해 반드시 결과물 돌려줌

    - 인자 외 다른 변수 사용 금지 = 숨겨진 입출력 제거

      ```javascript
      var arr = [1,2,3,4,5]
      var condition = function(x) { return x%2==0; }
      
      // 순수함수 x
      var ex = function(array) {
          return array.filter(condition)	// 받은 인자 array아닌 conditiont사용
      };
      ex(arr);
      
      
      // 순수 함수
      var ex = function(array, cond) {
          return array.filter(cond)	// array, cond = 인자
      };
      ex(arr, condition)
      
      ```
  
- **애플리케이션 상태가 공유되는 OOP와 대조**

- 선언형 프로그래밍 (반응형 프로그래밍)

  * How보다는 What을 설명하는 방식(무엇을 할 건지 표현)
  * 알고리즘을 명시하지 않고 목표만 명시
  * cf. 명령형 프로그래밍
    * 절차지향, 객체지향
    * 알고리즘 명시 (어떻게 할지 표현)

- java에서 함수형 프로그래밍

  - 람다식, stream api, 함수형 인터페이스

    ```java
    List<String> myList = Arrays.asList("a", "b", "c", "d", "e");
    
    // 기존방식 : 데이터 처리 방식이 한 눈에 보임 
    for(int i=0; i<myList.size(); i++){
    	String s = myList.get(i);
        if(s.startsWith("c")){
        	System.out.println(s.toUpperCase());
    	}
    }
    
    // stream API를 이용한 방식 : 한 눈에 내가 무엇을 구현했는지 알 수 있음
    myList.stream()
    	.filter(s -> s.startsWith("c"))
    	.map(String::toUpperCase)
    	.forEach(System.out::println);
    ```
