# 2. 고정 소수점 & 부동 소수점



### 1. 고정 소수점 (Fixed Point)

* 소수점이 찍힐 위치를 미리 정하고, 소수 표현(정수 + 소수)

* 구성

  ![고정소수점](https://user-images.githubusercontent.com/70613905/162688081-2f47fe07-b345-434e-a71d-c0c04f8b46bd.JPG)

  * 부호 
    * 1bit
    * 양수(1) , 음수(0)
  * 정수부 
    * 15bit
  * 소수부 
    * 16bit
    * 앞에서부터 채우며 남는 뒷자리는 다 0으로 채움
  * ex. -3.141592 = 부호(-) , 정수부(3) , 소수부(0.141592)

* 장점

  * 실수를 정수부 & 소수부로 표현하여 단순
  * 표현 범위가 너무 적음
    * 정수부와 실수부가 각각 15bit, 16bit라서

* cf. 음수 만들기

  * n의 이진수를 전부 반대로 바꿈(ex. 4bit에서 8 (1000) => 0111)
  * 위에서 +1을 함 (0111 + 1 = 1000)



### 2. 부동 소수점(Floating Point)

* 실수를 가수부 + 지수부로 표현하여 지수값에 따라 소수점이 이동

* 구성

  ​	![부동소수점](https://user-images.githubusercontent.com/70613905/162688169-4d91d8de-c9fe-45e1-8e30-c9ae1f6b5a47.JPG)

  * 가수 
    * 실수의 실제 값 
  * 지수
    * 크기를 표현
    * 가수의 어디에 소수점이 있는지 나타냄
  * ex. -314.625
    1. 부호 확인 => 음수니까 가장 앞비트 = 1 (1**00000000**00000000000000000000000)
    2. 314.625 이진수 구하기
       - 314 = 100111010.101
    3. 일의자리로 만들기
       - 1.00111010101x 2^8
       - 지수부 = 8 ,  소수부 = 00111010101 
    4. 소수점 부분을 가수부 23비트 앞부터 채우고, 남은자리는 0으로 채움
       * 100000000**00111010101000000000000**
    5. bias = 127 (32bit일 때) => 지수 + bias 를 이진수로 변환하고 지수부에 채움
       * 8 + 127 = 135 => 10000111
       * 1**10000111**00111010101000000000000

* 장점

  * 표현 범위가 넓어짐

* 단점

  * 오차 발생
    * 무한 소수의 경우 가수부가 표현하는 비트 수를 넘어가 손실 부분 발생
    * 실수의 경우 1/2^n으로 표현되는 경우만 오차 없이 계산
