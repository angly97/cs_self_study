# 5. HTTP/HTTPS



### 1. HTTP (Hyper Text Transfer Protocol)

* 인터넷에서 서버와 클라이언트 간 통신 규약

* 단점

  * 평문을 교환하므로, 도청 가능
  * 통신 상대 확인 안해서, 위장 가능
    * TCP의 3-way handshake는 상대가 있다는 걸 확인하지만, 상대가 위장한 건 알 수 없음
    * 의미없는 요청 받아 => Dos공격 방지 불가 => 대용량 트래픽 발생 => 자원 고갈 => 유저들 서비스 사용 불가
    
  * 완전성 증명도 안해서 변조 가능
  * 이를 해결하는 HTTPS 
  
  

### 2. HTTPS (Hyper Text Transfer Protocol Secure)

* SSL 프로토콜 사용해서 암호화도 하고 통신 상대도 증명하는 인터넷 통신 규약

* **HTTP통신하는 소켓을 SSL or TLS 프로토콜로 대체**

  * 본래 HTTP는 TCP와 직접 통신했지만, SSL과 통신하고, SSL이 TCP와 통신

* SSL (Secure Socket Layer; 보안 소켓 계층)

  * 대칭키 방식과 공개키 방식을 이용해서, 데이터를 암호화하여 인터넷 연결 보호하는 표준 기술

  *  대칭키 + 공개키 알고리즘 혼합
    * 대칭키를 교환할 때만 공개키 알고리즘 사용
    * 메시지 교환시에는 대칭키 알고리즘 사용

  * 과정

    1. A는 => B의 공개키로 통신에 쓰일 대칭키를 암호화하여 => 전송
    2. B는 비밀키로 복호화하여 대칭키 확인
    3. 그 대칭키로 통신
    
  * HTTP 단점 해결

    * 대칭키로 암호화하여, 도청 방지

    * 증명서(공개키)로 상대 확인하여, 위장 방지

      >CA(Certificate Authority)
      >
      >- 공개키 저장하는 신뢰성 검증된 제 3자 기관
      >- 서버나 클라이언트가 실재하는 사실 증명
      
    * 데이터에서 일정 길이 요약을 보고, 예상 값과 같은 지 확인하는 메시지 다이제스트로, 완전성 증명, 변조 방지
    
  
* 공개키 & 대칭키 교환 과정

  1. 서버 만드는 측은 공개키와 개인키 생성 후 => 공개키를 CA에 부탁
  2. CA기업은 그 공개키에 대한 SSL인증서를 CA 개인키로 암호화하여 => 서버에 제공
  4. 서버는 서버 공개키로 암호화된지 않은 요청이 오면, 이 인증서를 전송

     * SSL handshake 시작

       1. 클라이언트는 버전, 암호 알고리즘, 압축 방식 등의 정보가 담긴 client hello 메시지를 => 서버에게 보냄

       2. 서버는 이를 받고, 세션 ID와 인증서가 담긴 server hello 메시지 보냄
  4. 클라이언트는 CA 공개키로 복호화하여 서버공개키 얻음
  6. 클라이언트는 서버의 공개키로 대칭키 생성에 쓰일 난수를 암호화하여 전송

     * 만일 server hello 메시지에 클라이언트 인증서를 요청했을 경우, 클라이언트는 인증서 + 개인키로 암호화된 난수 전송
  6. 서버는 (클라이언트 인증서 확인 후), 복호화 된 난수로 대칭키 생성
  8. 클라이언트는 finished 메시지를 서버에 전송

     * 메시지에는 지금까지 보낸 교환 내역들을 해싱 후 => 대칭키로 암호화
  9. 서버도 교환내역 해싱 후 => 클라이언트에게 받은 값과 같다면 finished 메시지를 대칭키로 암호화 후 전송
  
* 모든 웹 페이지에 HTTPS 사용해도 됨?

  * 신뢰받은 CA기업이 아니라 자체 인증서의 경우 무조건 안전 X



### 3. HTTP Method GET VS POST

*  GET
  * 데이터는 HTTP Request 메시지 헤더에 uri가 담겨 전송됨
    * uri이라는 한정된 공간에 데이터가 담기기 때문에 데이터 크기 제한
    * 헤더에 담기니까 보안 X
* POST
  * HTTP Request 메시지 바디에 담겨 전송됨
    * GET방식보다 데이터 제한 크기 크고 안전



### 4. 웹 통신 흐름

* https://1q1w.github.io/http_network/HTTPNetwork_basic/)

1. 우리가 주소창에 uri 입력

2. 브라우저

   1. 브라우저는 uri에 맞는 HTTP Request 메시지 생성 후 => 웹서버로 전송 (Application L)
   2. 전송은 브라우저가 하지 않고, OS에 의뢰하여 메시지 전달
   3. OS는 DNS서버 조회해서 도메인명에 맞는 IP주소를 파악

3. 프로토콜 스택, LAN어뎁터

   * 프로토콜 스택
     * 계층 별 프로토콜 집합

   1. 프로토콜 스택이 Request 메시지를 segment로 조각낸 후, 포트번호를 붙여 패킷에 저장  (Transport L)
   2. 패킷에 MAC주소를 붙여서 LAN어댑터(Network Interface L)로 넘김 (Internet L)
   4. LAN 어댑터는 프레임을 전기신호로 변환 => 케이블에 보냄

4. 허브, 스위치, 라우터

   1. 허브(Physical L)를 경우하여 라우터(nternet L)에 프레임 도착
   2. 라우터는 패킷을 통신사(프로바이더)에게 전달

5. 엑세스 회선, 프로바이더

   1. 패킷은 인터넷 입구의 엑세스 회선(통신 회선)을 타고 통신사용 라우터까지 운반됨
   2. 수많은 라우터를 거쳐서 패킷이 목적지(웹 서버 측 LAN)로 감

6. 방화벽, 캐시서버

   1. 웹 서버 측 LAN의 방화벽이 도착한 패킷 검사
   2. 패킷이 웹 서버까지 안가도 되는지 검사하는 캐시 서버 존재
      * if 데이터가 캐시서버에 있으면 웹서버에 가지않고 응답

7. 웹 서버

   1. 웹 서버의 프로토콜 스택은 패킷의 메시지 복원 & 웹 서버 애플리케이션에 넘김
   2. 웹 서버 애플리케이션은 받은 Request 메시지에 Response 메시지를 넣어 클라이언트에 회송
   3. 왔던 방식대로 응답 메시지가 클라이언트에게 감



### 5. HTTP 상태 코드(HTTP State Code)

* 요청의 API 응답 상태를 코드를 통해 파악
* API문서 작성 시 꼭 필요한 정보
* 100번대
  * 정보 확인
* 200번대
  * 통신 성공
  * 200 (OK) : (GET) 요청 성공
  * 201 (Create) : (POST) 생성 요청 성공
  * 202 (Accecpted) : 요청 접수 O, 처리는 X
  * 204 (No Content) : 리소스 삭제 성공
* 300번대
  * 리다이렉트
  * 300 (Multiple Choice) : 요청 URI에 여러 리소스가 존재
  * 301 (Move Permanently) : **요청 URI가 새 위치로 옮겨감**
* 400번대
  * 클라이언트 오류
  * 400 (Bad Request) : API에서 정의하지 않은 요청 들어옴
    * uri 문법 잘못됨
  * 401 (Unauthorized) : 인증 오류 
    * 비로그인된 상태에서 허가되지 않은 접근
    * 서버는 클라이언트 누군지 모름
  * 403 (Forbidden) : 권한 밖 접근 시도 
    * 비/로그인 상태에서 허가되지 않은 접근 
    * 서버는 클라이언트 누군지 알고 있음
  * 404 (Not Found) : 요청 uri에 대한 리소스 존재 x 
    *  uri 가 없음
  * 409 (Confilct) : 모순
    * 서버 내 자원 충돌
    * ex. 내 아이디로 회원가입 했는데, 또 그 아이디로 회원가입 할 경우
  * 429 (Too Many Request) : 요청 횟수 상한 초과
* 500번대
  * 서버 오류
  * 500 (Internal Server Error) : 서버 내부 오류
    * 서버가 요청 처리 중 에러
  * 502 (Bad Gateway) : 불량 게이트웨이
    * 너무 많은 요청이 오는 경우. 병목현상